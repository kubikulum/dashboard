/**
 * Logto API references
 * API references for Logto services.  Note: The documentation is for Logto Cloud. If you are using Logto OSS, please refer to the response of `/api/swagger.json` endpoint on your Logto instance.
 *
 * The version of the OpenAPI document: Cloud
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Injectable, Optional } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { AxiosResponse } from 'axios';
import { Observable, from, of, switchMap } from 'rxjs';
import { AssignApplicationRolesRequest } from '../model/assignApplicationRolesRequest';
import { CreateApplicationProtectedAppMetadataCustomDomainRequest } from '../model/createApplicationProtectedAppMetadataCustomDomainRequest';
import { CreateApplicationRequest } from '../model/createApplicationRequest';
import { CreateApplicationUserConsentOrganizationRequest } from '../model/createApplicationUserConsentOrganizationRequest';
import { CreateApplicationUserConsentScopeRequest } from '../model/createApplicationUserConsentScopeRequest';
import { GetApplication200Response } from '../model/getApplication200Response';
import { GetApplicationSignInExperience200Response } from '../model/getApplicationSignInExperience200Response';
import { ListApplicationOrganizations200ResponseInner } from '../model/listApplicationOrganizations200ResponseInner';
import { ListApplicationRoles200ResponseInner } from '../model/listApplicationRoles200ResponseInner';
import { ListApplicationUserConsentOrganizations200Response } from '../model/listApplicationUserConsentOrganizations200Response';
import { ListApplicationUserConsentScopes200Response } from '../model/listApplicationUserConsentScopes200Response';
import { ListApplications200ResponseInner } from '../model/listApplications200ResponseInner';
import { ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInner } from '../model/listApplications200ResponseInnerProtectedAppMetadataCustomDomainsInner';
import { ListApplicationsIsThirdPartyParameter } from '../model/listApplicationsIsThirdPartyParameter';
import { ListApplicationsTypesParameter } from '../model/listApplicationsTypesParameter';
import { ReplaceApplicationRolesRequest } from '../model/replaceApplicationRolesRequest';
import { ReplaceApplicationSignInExperienceRequest } from '../model/replaceApplicationSignInExperienceRequest';
import { ReplaceApplicationUserConsentOrganizationsRequest } from '../model/replaceApplicationUserConsentOrganizationsRequest';
import { UpdateApplicationRequest } from '../model/updateApplicationRequest';
import { Configuration } from '../configuration';
import { COLLECTION_FORMATS } from '../variables';


@Injectable()
export class ApplicationsService {

    protected basePath = 'http://localhost';
    public defaultHeaders: Record<string,string> = {};
    public configuration = new Configuration();

    constructor(protected httpClient: HttpService, @Optional() configuration: Configuration) {
        this.configuration = configuration || this.configuration;
        this.basePath = configuration?.basePath || this.basePath;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        return consumes.includes(form);
    }

    /**
     * Assign API resource roles to application
     * Assign API resource roles to the specified application. The API resource roles will be added to the existing API resource roles.
     * @param applicationId The unique identifier of the application.
     * @param assignApplicationRolesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public assignApplicationRoles(applicationId: string, assignApplicationRolesRequest: AssignApplicationRolesRequest, ): Observable<AxiosResponse<any>>;
    public assignApplicationRoles(applicationId: string, assignApplicationRolesRequest: AssignApplicationRolesRequest, ): Observable<any> {
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling assignApplicationRoles.');
        }

        if (assignApplicationRolesRequest === null || assignApplicationRolesRequest === undefined) {
            throw new Error('Required parameter assignApplicationRolesRequest was null or undefined when calling assignApplicationRoles.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/api/applications/${encodeURIComponent(String(applicationId))}/roles`,
                    assignApplicationRolesRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Create an application
     * Create a new application with the given data.
     * @param createApplicationRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createApplication(createApplicationRequest: CreateApplicationRequest, ): Observable<AxiosResponse<ListApplications200ResponseInner>>;
    public createApplication(createApplicationRequest: CreateApplicationRequest, ): Observable<any> {
        if (createApplicationRequest === null || createApplicationRequest === undefined) {
            throw new Error('Required parameter createApplicationRequest was null or undefined when calling createApplication.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ListApplications200ResponseInner>(`${this.basePath}/api/applications`,
                    createApplicationRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Add a custom domain to the protected application.
     * Add a custom domain to the protected application. You\&#39;ll need to setup DNS record later. This feature is not available for open source version.
     * @param id The unique identifier of the application.
     * @param createApplicationProtectedAppMetadataCustomDomainRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createApplicationProtectedAppMetadataCustomDomain(id: string, createApplicationProtectedAppMetadataCustomDomainRequest: CreateApplicationProtectedAppMetadataCustomDomainRequest, ): Observable<AxiosResponse<any>>;
    public createApplicationProtectedAppMetadataCustomDomain(id: string, createApplicationProtectedAppMetadataCustomDomainRequest: CreateApplicationProtectedAppMetadataCustomDomainRequest, ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling createApplicationProtectedAppMetadataCustomDomain.');
        }

        if (createApplicationProtectedAppMetadataCustomDomainRequest === null || createApplicationProtectedAppMetadataCustomDomainRequest === undefined) {
            throw new Error('Required parameter createApplicationProtectedAppMetadataCustomDomainRequest was null or undefined when calling createApplicationProtectedAppMetadataCustomDomain.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/api/applications/${encodeURIComponent(String(id))}/protected-app-metadata/custom-domains`,
                    createApplicationProtectedAppMetadataCustomDomainRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Grant a list of organization access of a user for a application.
     * Grant a list of organization access of a user for a application by application id and user id. &lt;br/&gt; The user must be a member of all the organizations. &lt;br/&gt; Only third-party application needs to be granted access to organizations, all the other applications can request for all the organizations\&#39; access by default.
     * @param id The unique identifier of the application.
     * @param userId The unique identifier of the user.
     * @param createApplicationUserConsentOrganizationRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createApplicationUserConsentOrganization(id: string, userId: string, createApplicationUserConsentOrganizationRequest: CreateApplicationUserConsentOrganizationRequest, ): Observable<AxiosResponse<any>>;
    public createApplicationUserConsentOrganization(id: string, userId: string, createApplicationUserConsentOrganizationRequest: CreateApplicationUserConsentOrganizationRequest, ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling createApplicationUserConsentOrganization.');
        }

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling createApplicationUserConsentOrganization.');
        }

        if (createApplicationUserConsentOrganizationRequest === null || createApplicationUserConsentOrganizationRequest === undefined) {
            throw new Error('Required parameter createApplicationUserConsentOrganizationRequest was null or undefined when calling createApplicationUserConsentOrganization.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/api/applications/${encodeURIComponent(String(id))}/users/${encodeURIComponent(String(userId))}/consent-organizations`,
                    createApplicationUserConsentOrganizationRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Assign user consent scopes to application.
     * Assign the user consent scopes to an application by application id
     * @param applicationId The unique identifier of the application.
     * @param createApplicationUserConsentScopeRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createApplicationUserConsentScope(applicationId: string, createApplicationUserConsentScopeRequest: CreateApplicationUserConsentScopeRequest, ): Observable<AxiosResponse<any>>;
    public createApplicationUserConsentScope(applicationId: string, createApplicationUserConsentScopeRequest: CreateApplicationUserConsentScopeRequest, ): Observable<any> {
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling createApplicationUserConsentScope.');
        }

        if (createApplicationUserConsentScopeRequest === null || createApplicationUserConsentScopeRequest === undefined) {
            throw new Error('Required parameter createApplicationUserConsentScopeRequest was null or undefined when calling createApplicationUserConsentScope.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/api/applications/${encodeURIComponent(String(applicationId))}/user-consent-scopes`,
                    createApplicationUserConsentScopeRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Delete application
     * Delete application by ID.
     * @param id The unique identifier of the application.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteApplication(id: string, ): Observable<AxiosResponse<any>>;
    public deleteApplication(id: string, ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteApplication.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<any>(`${this.basePath}/api/applications/${encodeURIComponent(String(id))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Delete a custom domain.
     * Add a custom domain. This feature is not available for open source version.
     * @param id The unique identifier of the application.
     * @param domain 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteApplicationProtectedAppMetadataCustomDomain(id: string, domain: string, ): Observable<AxiosResponse<any>>;
    public deleteApplicationProtectedAppMetadataCustomDomain(id: string, domain: string, ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteApplicationProtectedAppMetadataCustomDomain.');
        }

        if (domain === null || domain === undefined) {
            throw new Error('Required parameter domain was null or undefined when calling deleteApplicationProtectedAppMetadataCustomDomain.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<any>(`${this.basePath}/api/applications/${encodeURIComponent(String(id))}/protected-app-metadata/custom-domains/${encodeURIComponent(String(domain))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Remove a API resource role from application
     * Remove a API resource role from the specified application.
     * @param applicationId The unique identifier of the application.
     * @param roleId The unique identifier of the role.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteApplicationRole(applicationId: string, roleId: string, ): Observable<AxiosResponse<any>>;
    public deleteApplicationRole(applicationId: string, roleId: string, ): Observable<any> {
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling deleteApplicationRole.');
        }

        if (roleId === null || roleId === undefined) {
            throw new Error('Required parameter roleId was null or undefined when calling deleteApplicationRole.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<any>(`${this.basePath}/api/applications/${encodeURIComponent(String(applicationId))}/roles/${encodeURIComponent(String(roleId))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Revoke a user\&#39;s access to an organization for a application.
     * Revoke a user\&#39;s access to an organization for a application by application id, user id and organization id.
     * @param id The unique identifier of the application.
     * @param userId The unique identifier of the user.
     * @param organizationId The unique identifier of the organization.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteApplicationUserConsentOrganization(id: string, userId: string, organizationId: string, ): Observable<AxiosResponse<any>>;
    public deleteApplicationUserConsentOrganization(id: string, userId: string, organizationId: string, ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteApplicationUserConsentOrganization.');
        }

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling deleteApplicationUserConsentOrganization.');
        }

        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling deleteApplicationUserConsentOrganization.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<any>(`${this.basePath}/api/applications/${encodeURIComponent(String(id))}/users/${encodeURIComponent(String(userId))}/consent-organizations/${encodeURIComponent(String(organizationId))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Remove user consent scope from application.
     * Remove the user consent scope from an application by application id, scope type and scope id
     * @param applicationId The unique identifier of the application.
     * @param scopeType 
     * @param scopeId The unique identifier of the scope.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteApplicationUserConsentScope(applicationId: string, scopeType: 'organization-scopes' | 'resource-scopes' | 'organization-resource-scopes' | 'user-scopes', scopeId: string, ): Observable<AxiosResponse<any>>;
    public deleteApplicationUserConsentScope(applicationId: string, scopeType: 'organization-scopes' | 'resource-scopes' | 'organization-resource-scopes' | 'user-scopes', scopeId: string, ): Observable<any> {
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling deleteApplicationUserConsentScope.');
        }

        if (scopeType === null || scopeType === undefined) {
            throw new Error('Required parameter scopeType was null or undefined when calling deleteApplicationUserConsentScope.');
        }

        if (scopeId === null || scopeId === undefined) {
            throw new Error('Required parameter scopeId was null or undefined when calling deleteApplicationUserConsentScope.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<any>(`${this.basePath}/api/applications/${encodeURIComponent(String(applicationId))}/user-consent-scopes/${encodeURIComponent(String(scopeType))}/${encodeURIComponent(String(scopeId))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Get application
     * Get application details by ID.
     * @param id The unique identifier of the application.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getApplication(id: string, ): Observable<AxiosResponse<GetApplication200Response>>;
    public getApplication(id: string, ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getApplication.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<GetApplication200Response>(`${this.basePath}/api/applications/${encodeURIComponent(String(id))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Get the application level sign-in experience
     * Get application level sign-in experience for a given application.   - Only branding properties and terms links customization is supported for now.    - Only third-party applications can have the sign-in experience customization for now.
     * @param applicationId The unique identifier of the application.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getApplicationSignInExperience(applicationId: string, ): Observable<AxiosResponse<GetApplicationSignInExperience200Response>>;
    public getApplicationSignInExperience(applicationId: string, ): Observable<any> {
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getApplicationSignInExperience.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<GetApplicationSignInExperience200Response>(`${this.basePath}/api/applications/${encodeURIComponent(String(applicationId))}/sign-in-experience`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Get application organizations
     * Get the list of organizations that an application is associated with.
     * @param id The unique identifier of the application.
     * @param page Page number (starts from 1).
     * @param pageSize Entries per page.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listApplicationOrganizations(id: string, page?: number, pageSize?: number, ): Observable<AxiosResponse<Array<ListApplicationOrganizations200ResponseInner>>>;
    public listApplicationOrganizations(id: string, page?: number, pageSize?: number, ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling listApplicationOrganizations.');
        }

        let queryParameters = new URLSearchParams();
        if (page !== undefined && page !== null) {
            queryParameters.append('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters.append('page_size', <any>pageSize);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<Array<ListApplicationOrganizations200ResponseInner>>(`${this.basePath}/api/applications/${encodeURIComponent(String(id))}/organizations`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Get the list of custom domains of the protected application.
     * Get the list of custom domains of the protected application. This feature is not available for open source version.
     * @param id The unique identifier of the application.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listApplicationProtectedAppMetadataCustomDomains(id: string, ): Observable<AxiosResponse<Array<ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInner>>>;
    public listApplicationProtectedAppMetadataCustomDomains(id: string, ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling listApplicationProtectedAppMetadataCustomDomains.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<Array<ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInner>>(`${this.basePath}/api/applications/${encodeURIComponent(String(id))}/protected-app-metadata/custom-domains`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Get application API resource roles
     * Get API resource roles assigned to the specified application with pagination.
     * @param applicationId The unique identifier of the application.
     * @param page Page number (starts from 1).
     * @param pageSize Entries per page.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listApplicationRoles(applicationId: string, page?: number, pageSize?: number, ): Observable<AxiosResponse<Array<ListApplicationRoles200ResponseInner>>>;
    public listApplicationRoles(applicationId: string, page?: number, pageSize?: number, ): Observable<any> {
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling listApplicationRoles.');
        }

        let queryParameters = new URLSearchParams();
        if (page !== undefined && page !== null) {
            queryParameters.append('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters.append('page_size', <any>pageSize);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<Array<ListApplicationRoles200ResponseInner>>(`${this.basePath}/api/applications/${encodeURIComponent(String(applicationId))}/roles`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * List all the user consented organizations of a application.
     * List all the user consented organizations for a application by application id and user id.
     * @param id The unique identifier of the application.
     * @param userId The unique identifier of the user.
     * @param page Page number (starts from 1).
     * @param pageSize Entries per page.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listApplicationUserConsentOrganizations(id: string, userId: string, page?: number, pageSize?: number, ): Observable<AxiosResponse<ListApplicationUserConsentOrganizations200Response>>;
    public listApplicationUserConsentOrganizations(id: string, userId: string, page?: number, pageSize?: number, ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling listApplicationUserConsentOrganizations.');
        }

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling listApplicationUserConsentOrganizations.');
        }

        let queryParameters = new URLSearchParams();
        if (page !== undefined && page !== null) {
            queryParameters.append('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters.append('page_size', <any>pageSize);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ListApplicationUserConsentOrganizations200Response>(`${this.basePath}/api/applications/${encodeURIComponent(String(id))}/users/${encodeURIComponent(String(userId))}/consent-organizations`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * List all the user consent scopes of an application.
     * List all the user consent scopes of an application by application id
     * @param applicationId The unique identifier of the application.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listApplicationUserConsentScopes(applicationId: string, ): Observable<AxiosResponse<ListApplicationUserConsentScopes200Response>>;
    public listApplicationUserConsentScopes(applicationId: string, ): Observable<any> {
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling listApplicationUserConsentScopes.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ListApplicationUserConsentScopes200Response>(`${this.basePath}/api/applications/${encodeURIComponent(String(applicationId))}/user-consent-scopes`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Get applications
     * Get applications that match the given query with pagination.
     * @param types An array of application types to filter applications.
     * @param excludeRoleId 
     * @param excludeOrganizationId 
     * @param isThirdParty 
     * @param page Page number (starts from 1).
     * @param pageSize Entries per page.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listApplications(types?: ListApplicationsTypesParameter, excludeRoleId?: string, excludeOrganizationId?: string, isThirdParty?: ListApplicationsIsThirdPartyParameter, page?: number, pageSize?: number, ): Observable<AxiosResponse<Array<ListApplications200ResponseInner>>>;
    public listApplications(types?: ListApplicationsTypesParameter, excludeRoleId?: string, excludeOrganizationId?: string, isThirdParty?: ListApplicationsIsThirdPartyParameter, page?: number, pageSize?: number, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (types !== undefined && types !== null) {
            queryParameters.append('types', <any>types);
        }
        if (excludeRoleId !== undefined && excludeRoleId !== null) {
            queryParameters.append('excludeRoleId', <any>excludeRoleId);
        }
        if (excludeOrganizationId !== undefined && excludeOrganizationId !== null) {
            queryParameters.append('excludeOrganizationId', <any>excludeOrganizationId);
        }
        if (isThirdParty !== undefined && isThirdParty !== null) {
            queryParameters.append('isThirdParty', <any>isThirdParty);
        }
        if (page !== undefined && page !== null) {
            queryParameters.append('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters.append('page_size', <any>pageSize);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<Array<ListApplications200ResponseInner>>(`${this.basePath}/api/applications`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Update API resource roles for application
     * Update API resource roles assigned to the specified application. This will replace the existing API resource roles.
     * @param applicationId The unique identifier of the application.
     * @param replaceApplicationRolesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceApplicationRoles(applicationId: string, replaceApplicationRolesRequest: ReplaceApplicationRolesRequest, ): Observable<AxiosResponse<any>>;
    public replaceApplicationRoles(applicationId: string, replaceApplicationRolesRequest: ReplaceApplicationRolesRequest, ): Observable<any> {
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling replaceApplicationRoles.');
        }

        if (replaceApplicationRolesRequest === null || replaceApplicationRolesRequest === undefined) {
            throw new Error('Required parameter replaceApplicationRolesRequest was null or undefined when calling replaceApplicationRoles.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<any>(`${this.basePath}/api/applications/${encodeURIComponent(String(applicationId))}/roles`,
                    replaceApplicationRolesRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Update application level sign-in experience
     * Update application level sign-in experience for the specified application. Create a new sign-in experience if it does not exist.   - Only branding properties and terms links customization is supported for now.    - Only third-party applications can be customized for now.    - Application level sign-in experience customization is optional, if provided, it will override the default branding and terms links.
     * @param applicationId The unique identifier of the application.
     * @param replaceApplicationSignInExperienceRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceApplicationSignInExperience(applicationId: string, replaceApplicationSignInExperienceRequest: ReplaceApplicationSignInExperienceRequest, ): Observable<AxiosResponse<GetApplicationSignInExperience200Response>>;
    public replaceApplicationSignInExperience(applicationId: string, replaceApplicationSignInExperienceRequest: ReplaceApplicationSignInExperienceRequest, ): Observable<any> {
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling replaceApplicationSignInExperience.');
        }

        if (replaceApplicationSignInExperienceRequest === null || replaceApplicationSignInExperienceRequest === undefined) {
            throw new Error('Required parameter replaceApplicationSignInExperienceRequest was null or undefined when calling replaceApplicationSignInExperience.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<GetApplicationSignInExperience200Response>(`${this.basePath}/api/applications/${encodeURIComponent(String(applicationId))}/sign-in-experience`,
                    replaceApplicationSignInExperienceRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Grant a list of organization access of a user for a application.
     * Grant a list of organization access of a user for a application by application id and user id. &lt;br/&gt; The user must be a member of all the organizations. &lt;br/&gt; Only third-party application needs to be granted access to organizations, all the other applications can request for all the organizations\&#39; access by default.
     * @param id The unique identifier of the application.
     * @param userId The unique identifier of the user.
     * @param replaceApplicationUserConsentOrganizationsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceApplicationUserConsentOrganizations(id: string, userId: string, replaceApplicationUserConsentOrganizationsRequest: ReplaceApplicationUserConsentOrganizationsRequest, ): Observable<AxiosResponse<any>>;
    public replaceApplicationUserConsentOrganizations(id: string, userId: string, replaceApplicationUserConsentOrganizationsRequest: ReplaceApplicationUserConsentOrganizationsRequest, ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling replaceApplicationUserConsentOrganizations.');
        }

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling replaceApplicationUserConsentOrganizations.');
        }

        if (replaceApplicationUserConsentOrganizationsRequest === null || replaceApplicationUserConsentOrganizationsRequest === undefined) {
            throw new Error('Required parameter replaceApplicationUserConsentOrganizationsRequest was null or undefined when calling replaceApplicationUserConsentOrganizations.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<any>(`${this.basePath}/api/applications/${encodeURIComponent(String(id))}/users/${encodeURIComponent(String(userId))}/consent-organizations`,
                    replaceApplicationUserConsentOrganizationsRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Update application
     * Update application details by ID with the given data.
     * @param id The unique identifier of the application.
     * @param updateApplicationRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateApplication(id: string, updateApplicationRequest: UpdateApplicationRequest, ): Observable<AxiosResponse<ListApplications200ResponseInner>>;
    public updateApplication(id: string, updateApplicationRequest: UpdateApplicationRequest, ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateApplication.');
        }

        if (updateApplicationRequest === null || updateApplicationRequest === undefined) {
            throw new Error('Required parameter updateApplicationRequest was null or undefined when calling updateApplication.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<ListApplications200ResponseInner>(`${this.basePath}/api/applications/${encodeURIComponent(String(id))}`,
                    updateApplicationRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
}
