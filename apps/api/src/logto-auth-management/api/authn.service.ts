/**
 * Logto API references
 * API references for Logto services.  Note: The documentation is for Logto Cloud. If you are using Logto OSS, please refer to the response of `/api/swagger.json` endpoint on your Logto instance.
 *
 * The version of the OpenAPI document: Cloud
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Injectable, Optional } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { AxiosResponse } from 'axios';
import { Observable, from, of, switchMap } from 'rxjs';
import { AssertSingleSignOnSamlRequest } from '../model/assertSingleSignOnSamlRequest';
import { GetHasuraAuth200Response } from '../model/getHasuraAuth200Response';
import { Configuration } from '../configuration';
import { COLLECTION_FORMATS } from '../variables';


@Injectable()
export class AuthnService {

    protected basePath = 'http://localhost';
    public defaultHeaders: Record<string,string> = {};
    public configuration = new Configuration();

    constructor(protected httpClient: HttpService, @Optional() configuration: Configuration) {
        this.configuration = configuration || this.configuration;
        this.basePath = configuration?.basePath || this.basePath;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        return consumes.includes(form);
    }

    /**
     * SAML ACS endpoint (social)
     * The Assertion Consumer Service (ACS) endpoint for Simple Assertion Markup Language (SAML) social connectors.  SAML social connectors are deprecated. Use the SSO SAML connector instead.
     * @param connectorId The unique identifier of the connector.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public assertSaml(connectorId: string, body: object, ): Observable<AxiosResponse<any>>;
    public assertSaml(connectorId: string, body: object, ): Observable<any> {
        if (connectorId === null || connectorId === undefined) {
            throw new Error('Required parameter connectorId was null or undefined when calling assertSaml.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling assertSaml.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/api/authn/saml/${encodeURIComponent(String(connectorId))}`,
                    body,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * SAML ACS endpoint (SSO)
     * The Assertion Consumer Service (ACS) endpoint for Simple Assertion Markup Language (SAML) single sign-on (SSO) connectors.  This endpoint is used to complete the SAML SSO authentication flow. It receives the SAML assertion response from the identity provider (IdP) and redirects the user to complete the authentication flow.
     * @param connectorId The unique identifier of the connector.
     * @param assertSingleSignOnSamlRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public assertSingleSignOnSaml(connectorId: string, assertSingleSignOnSamlRequest: AssertSingleSignOnSamlRequest, ): Observable<AxiosResponse<any>>;
    public assertSingleSignOnSaml(connectorId: string, assertSingleSignOnSamlRequest: AssertSingleSignOnSamlRequest, ): Observable<any> {
        if (connectorId === null || connectorId === undefined) {
            throw new Error('Required parameter connectorId was null or undefined when calling assertSingleSignOnSaml.');
        }

        if (assertSingleSignOnSamlRequest === null || assertSingleSignOnSamlRequest === undefined) {
            throw new Error('Required parameter assertSingleSignOnSamlRequest was null or undefined when calling assertSingleSignOnSaml.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/api/authn/single-sign-on/saml/${encodeURIComponent(String(connectorId))}`,
                    assertSingleSignOnSamlRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Hasura auth hook endpoint
     * The &#x60;HASURA_GRAPHQL_AUTH_HOOK&#x60; endpoint for Hasura auth. Use this endpoint to integrate Hasura\&#39;s [webhook authentication flow](https://hasura.io/docs/latest/auth/authentication/webhook/).
     * @param resource 
     * @param unauthorizedRole 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getHasuraAuth(resource: string, unauthorizedRole?: string, ): Observable<AxiosResponse<GetHasuraAuth200Response>>;
    public getHasuraAuth(resource: string, unauthorizedRole?: string, ): Observable<any> {
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling getHasuraAuth.');
        }

        let queryParameters = new URLSearchParams();
        if (resource !== undefined && resource !== null) {
            queryParameters.append('resource', <any>resource);
        }
        if (unauthorizedRole !== undefined && unauthorizedRole !== null) {
            queryParameters.append('unauthorizedRole', <any>unauthorizedRole);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<GetHasuraAuth200Response>(`${this.basePath}/api/authn/hasura`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
}
