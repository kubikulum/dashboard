/**
 * Logto API references
 * API references for Logto services.  Note: The documentation is for Logto Cloud. If you are using Logto OSS, please refer to the response of `/api/swagger.json` endpoint on your Logto instance.
 *
 * The version of the OpenAPI document: Cloud
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Injectable, Optional } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { AxiosResponse } from 'axios';
import { Observable, from, of, switchMap } from 'rxjs';
import { GetAdminConsoleConfig200Response } from '../model/getAdminConsoleConfig200Response';
import { GetJwtCustomizer200Response } from '../model/getJwtCustomizer200Response';
import { GetOidcKeys200ResponseInner } from '../model/getOidcKeys200ResponseInner';
import { ListJwtCustomizers200ResponseInner } from '../model/listJwtCustomizers200ResponseInner';
import { RotateOidcKeysRequest } from '../model/rotateOidcKeysRequest';
import { TestJwtCustomizerRequest } from '../model/testJwtCustomizerRequest';
import { UpdateAdminConsoleConfigRequest } from '../model/updateAdminConsoleConfigRequest';
import { UpsertJwtCustomizerRequest } from '../model/upsertJwtCustomizerRequest';
import { Configuration } from '../configuration';
import { COLLECTION_FORMATS } from '../variables';


@Injectable()
export class ConfigsService {

    protected basePath = 'http://localhost';
    public defaultHeaders: Record<string,string> = {};
    public configuration = new Configuration();

    constructor(protected httpClient: HttpService, @Optional() configuration: Configuration) {
        this.configuration = configuration || this.configuration;
        this.basePath = configuration?.basePath || this.basePath;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        return consumes.includes(form);
    }

    /**
     * Delete JWT customizer
     * Delete the JWT customizer for the given token type.
     * @param tokenTypePath The token type path to delete the JWT customizer for.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteJwtCustomizer(tokenTypePath: 'access-token' | 'client-credentials', ): Observable<AxiosResponse<any>>;
    public deleteJwtCustomizer(tokenTypePath: 'access-token' | 'client-credentials', ): Observable<any> {
        if (tokenTypePath === null || tokenTypePath === undefined) {
            throw new Error('Required parameter tokenTypePath was null or undefined when calling deleteJwtCustomizer.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<any>(`${this.basePath}/api/configs/jwt-customizer/${encodeURIComponent(String(tokenTypePath))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Delete OIDC key
     * Delete an OIDC signing key by key type and key ID.
     * @param keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
     * @param keyId The unique identifier of the key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteOidcKey(keyType: 'private-keys' | 'cookie-keys', keyId: string, ): Observable<AxiosResponse<any>>;
    public deleteOidcKey(keyType: 'private-keys' | 'cookie-keys', keyId: string, ): Observable<any> {
        if (keyType === null || keyType === undefined) {
            throw new Error('Required parameter keyType was null or undefined when calling deleteOidcKey.');
        }

        if (keyId === null || keyId === undefined) {
            throw new Error('Required parameter keyId was null or undefined when calling deleteOidcKey.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<any>(`${this.basePath}/api/configs/oidc/${encodeURIComponent(String(keyType))}/${encodeURIComponent(String(keyId))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Get admin console config
     * Get the global configuration object for Logto Console.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAdminConsoleConfig(): Observable<AxiosResponse<GetAdminConsoleConfig200Response>>;
    public getAdminConsoleConfig(): Observable<any> {
        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<GetAdminConsoleConfig200Response>(`${this.basePath}/api/configs/admin-console`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Get JWT customizer
     * Get the JWT customizer for the given token type.
     * @param tokenTypePath The token type to get the JWT customizer for.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getJwtCustomizer(tokenTypePath: 'access-token' | 'client-credentials', ): Observable<AxiosResponse<GetJwtCustomizer200Response>>;
    public getJwtCustomizer(tokenTypePath: 'access-token' | 'client-credentials', ): Observable<any> {
        if (tokenTypePath === null || tokenTypePath === undefined) {
            throw new Error('Required parameter tokenTypePath was null or undefined when calling getJwtCustomizer.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<GetJwtCustomizer200Response>(`${this.basePath}/api/configs/jwt-customizer/${encodeURIComponent(String(tokenTypePath))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Get OIDC keys
     * Get OIDC signing keys by key type. The actual key will be redacted from the result.
     * @param keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOidcKeys(keyType: 'private-keys' | 'cookie-keys', ): Observable<AxiosResponse<Array<GetOidcKeys200ResponseInner>>>;
    public getOidcKeys(keyType: 'private-keys' | 'cookie-keys', ): Observable<any> {
        if (keyType === null || keyType === undefined) {
            throw new Error('Required parameter keyType was null or undefined when calling getOidcKeys.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<Array<GetOidcKeys200ResponseInner>>(`${this.basePath}/api/configs/oidc/${encodeURIComponent(String(keyType))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Get all JWT customizers
     * Get all JWT customizers for the tenant.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listJwtCustomizers(): Observable<AxiosResponse<Array<ListJwtCustomizers200ResponseInner>>>;
    public listJwtCustomizers(): Observable<any> {
        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<Array<ListJwtCustomizers200ResponseInner>>(`${this.basePath}/api/configs/jwt-customizer`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Rotate OIDC keys
     * A new key will be generated and prepend to the list of keys.  Only two recent keys will be kept. The oldest key will be automatically removed if there are more than two keys.
     * @param keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
     * @param rotateOidcKeysRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public rotateOidcKeys(keyType: 'private-keys' | 'cookie-keys', rotateOidcKeysRequest: RotateOidcKeysRequest, ): Observable<AxiosResponse<Array<GetOidcKeys200ResponseInner>>>;
    public rotateOidcKeys(keyType: 'private-keys' | 'cookie-keys', rotateOidcKeysRequest: RotateOidcKeysRequest, ): Observable<any> {
        if (keyType === null || keyType === undefined) {
            throw new Error('Required parameter keyType was null or undefined when calling rotateOidcKeys.');
        }

        if (rotateOidcKeysRequest === null || rotateOidcKeysRequest === undefined) {
            throw new Error('Required parameter rotateOidcKeysRequest was null or undefined when calling rotateOidcKeys.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<Array<GetOidcKeys200ResponseInner>>(`${this.basePath}/api/configs/oidc/${encodeURIComponent(String(keyType))}/rotate`,
                    rotateOidcKeysRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Test JWT customizer
     * Test the JWT customizer script with the given sample context and sample token payload.
     * @param testJwtCustomizerRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public testJwtCustomizer(testJwtCustomizerRequest: TestJwtCustomizerRequest, ): Observable<AxiosResponse<object>>;
    public testJwtCustomizer(testJwtCustomizerRequest: TestJwtCustomizerRequest, ): Observable<any> {
        if (testJwtCustomizerRequest === null || testJwtCustomizerRequest === undefined) {
            throw new Error('Required parameter testJwtCustomizerRequest was null or undefined when calling testJwtCustomizer.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<object>(`${this.basePath}/api/configs/jwt-customizer/test`,
                    testJwtCustomizerRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Update admin console config
     * Update the global configuration object for Logto Console. This method performs a partial update.
     * @param updateAdminConsoleConfigRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateAdminConsoleConfig(updateAdminConsoleConfigRequest: UpdateAdminConsoleConfigRequest, ): Observable<AxiosResponse<GetAdminConsoleConfig200Response>>;
    public updateAdminConsoleConfig(updateAdminConsoleConfigRequest: UpdateAdminConsoleConfigRequest, ): Observable<any> {
        if (updateAdminConsoleConfigRequest === null || updateAdminConsoleConfigRequest === undefined) {
            throw new Error('Required parameter updateAdminConsoleConfigRequest was null or undefined when calling updateAdminConsoleConfig.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<GetAdminConsoleConfig200Response>(`${this.basePath}/api/configs/admin-console`,
                    updateAdminConsoleConfigRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Update JWT customizer
     * Update the JWT customizer for the given token type.
     * @param tokenTypePath The token type to update a JWT customizer for.
     * @param upsertJwtCustomizerRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateJwtCustomizer(tokenTypePath: 'access-token' | 'client-credentials', upsertJwtCustomizerRequest: UpsertJwtCustomizerRequest, ): Observable<AxiosResponse<GetJwtCustomizer200Response>>;
    public updateJwtCustomizer(tokenTypePath: 'access-token' | 'client-credentials', upsertJwtCustomizerRequest: UpsertJwtCustomizerRequest, ): Observable<any> {
        if (tokenTypePath === null || tokenTypePath === undefined) {
            throw new Error('Required parameter tokenTypePath was null or undefined when calling updateJwtCustomizer.');
        }

        if (upsertJwtCustomizerRequest === null || upsertJwtCustomizerRequest === undefined) {
            throw new Error('Required parameter upsertJwtCustomizerRequest was null or undefined when calling updateJwtCustomizer.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<GetJwtCustomizer200Response>(`${this.basePath}/api/configs/jwt-customizer/${encodeURIComponent(String(tokenTypePath))}`,
                    upsertJwtCustomizerRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Create or update JWT customizer
     * Create or update a JWT customizer for the given token type.
     * @param tokenTypePath The token type to create a JWT customizer for.
     * @param upsertJwtCustomizerRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public upsertJwtCustomizer(tokenTypePath: 'access-token' | 'client-credentials', upsertJwtCustomizerRequest: UpsertJwtCustomizerRequest, ): Observable<AxiosResponse<GetJwtCustomizer200Response>>;
    public upsertJwtCustomizer(tokenTypePath: 'access-token' | 'client-credentials', upsertJwtCustomizerRequest: UpsertJwtCustomizerRequest, ): Observable<any> {
        if (tokenTypePath === null || tokenTypePath === undefined) {
            throw new Error('Required parameter tokenTypePath was null or undefined when calling upsertJwtCustomizer.');
        }

        if (upsertJwtCustomizerRequest === null || upsertJwtCustomizerRequest === undefined) {
            throw new Error('Required parameter upsertJwtCustomizerRequest was null or undefined when calling upsertJwtCustomizer.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ManagementApi) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<GetJwtCustomizer200Response>(`${this.basePath}/api/configs/jwt-customizer/${encodeURIComponent(String(tokenTypePath))}`,
                    upsertJwtCustomizerRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
}
