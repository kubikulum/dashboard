/**
 * Gardener
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.98.0-dev
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Injectable, Optional } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { AxiosResponse } from 'axios';
import { Observable, from, of, switchMap } from 'rxjs';
import { ComGithubGardenerGardenerPkgApisAuthenticationV1alpha1AdminKubeconfigRequest } from '../model/comGithubGardenerGardenerPkgApisAuthenticationV1alpha1AdminKubeconfigRequest';
import { ComGithubGardenerGardenerPkgApisAuthenticationV1alpha1ViewerKubeconfigRequest } from '../model/comGithubGardenerGardenerPkgApisAuthenticationV1alpha1ViewerKubeconfigRequest';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1BackupBucketList } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1BackupBucketList';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntryList } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1BackupEntryList';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1CloudProfileList } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1CloudProfileList';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeploymentList } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeploymentList';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallationList } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallationList';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistrationList } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistrationList';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1ExposureClassList } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1ExposureClassList';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1InternalSecretList } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1InternalSecretList';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfileList } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfileList';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1Project } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1Project';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1ProjectList } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1ProjectList';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1Quota } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1Quota';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1QuotaList } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1QuotaList';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1SecretBindingList } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1SecretBindingList';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1Seed } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1Seed';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1SeedList } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1SeedList';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1Shoot';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1ShootList } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1ShootList';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1ShootState } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1ShootState';
import { ComGithubGardenerGardenerPkgApisCoreV1beta1ShootStateList } from '../model/comGithubGardenerGardenerPkgApisCoreV1beta1ShootStateList';
import { IoK8sApimachineryPkgApisMetaV1APIResourceList } from '../model/ioK8sApimachineryPkgApisMetaV1APIResourceList';
import { IoK8sApimachineryPkgApisMetaV1DeleteOptions } from '../model/ioK8sApimachineryPkgApisMetaV1DeleteOptions';
import { IoK8sApimachineryPkgApisMetaV1Status } from '../model/ioK8sApimachineryPkgApisMetaV1Status';
import { IoK8sApimachineryPkgApisMetaV1WatchEvent } from '../model/ioK8sApimachineryPkgApisMetaV1WatchEvent';
import { Configuration } from '../configuration';
import { COLLECTION_FORMATS } from '../variables';


@Injectable()
export class CoreGardenerCloudV1beta1Service {

    protected basePath = 'http://localhost';
    public defaultHeaders: Record<string,string> = {};
    public configuration = new Configuration();

    constructor(protected httpClient: HttpService, @Optional() configuration: Configuration) {
        this.configuration = configuration || this.configuration;
        this.basePath = configuration?.basePath || this.basePath;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        return consumes.includes(form);
    }

    /**
     * 
     * create a BackupBucket
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createCoreGardenerCloudV1beta1BackupBucket(comGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket: ComGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket>>;
    public createCoreGardenerCloudV1beta1BackupBucket(comGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket: ComGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (comGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket === null || comGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket was null or undefined when calling createCoreGardenerCloudV1beta1BackupBucket.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/backupbuckets`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * create a CloudProfile
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createCoreGardenerCloudV1beta1CloudProfile(comGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile: ComGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile>>;
    public createCoreGardenerCloudV1beta1CloudProfile(comGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile: ComGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (comGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile === null || comGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile was null or undefined when calling createCoreGardenerCloudV1beta1CloudProfile.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ComGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/cloudprofiles`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * create a ControllerDeployment
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createCoreGardenerCloudV1beta1ControllerDeployment(comGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment: ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment>>;
    public createCoreGardenerCloudV1beta1ControllerDeployment(comGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment: ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (comGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment === null || comGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment was null or undefined when calling createCoreGardenerCloudV1beta1ControllerDeployment.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/controllerdeployments`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * create a ControllerInstallation
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createCoreGardenerCloudV1beta1ControllerInstallation(comGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation: ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation>>;
    public createCoreGardenerCloudV1beta1ControllerInstallation(comGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation: ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (comGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation === null || comGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation was null or undefined when calling createCoreGardenerCloudV1beta1ControllerInstallation.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/controllerinstallations`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * create a ControllerRegistration
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createCoreGardenerCloudV1beta1ControllerRegistration(comGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration: ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration>>;
    public createCoreGardenerCloudV1beta1ControllerRegistration(comGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration: ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (comGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration === null || comGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration was null or undefined when calling createCoreGardenerCloudV1beta1ControllerRegistration.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/controllerregistrations`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * create an ExposureClass
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createCoreGardenerCloudV1beta1ExposureClass(comGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass: ComGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass>>;
    public createCoreGardenerCloudV1beta1ExposureClass(comGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass: ComGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (comGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass === null || comGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass was null or undefined when calling createCoreGardenerCloudV1beta1ExposureClass.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ComGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/exposureclasses`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * create a BackupEntry
     * @param namespace object name and auth scope, such as for teams and projects
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createCoreGardenerCloudV1beta1NamespacedBackupEntry(namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry: ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry>>;
    public createCoreGardenerCloudV1beta1NamespacedBackupEntry(namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry: ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createCoreGardenerCloudV1beta1NamespacedBackupEntry.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry === null || comGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry was null or undefined when calling createCoreGardenerCloudV1beta1NamespacedBackupEntry.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/backupentries`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * create an InternalSecret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createCoreGardenerCloudV1beta1NamespacedInternalSecret(namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret: ComGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret>>;
    public createCoreGardenerCloudV1beta1NamespacedInternalSecret(namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret: ComGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createCoreGardenerCloudV1beta1NamespacedInternalSecret.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret === null || comGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret was null or undefined when calling createCoreGardenerCloudV1beta1NamespacedInternalSecret.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ComGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/internalsecrets`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * create a NamespacedCloudProfile
     * @param namespace object name and auth scope, such as for teams and projects
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile(namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile: ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile>>;
    public createCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile(namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile: ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile === null || comGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile was null or undefined when calling createCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/namespacedcloudprofiles`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * create a Quota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1Quota 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createCoreGardenerCloudV1beta1NamespacedQuota(namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1Quota: ComGithubGardenerGardenerPkgApisCoreV1beta1Quota, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Quota>>;
    public createCoreGardenerCloudV1beta1NamespacedQuota(namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1Quota: ComGithubGardenerGardenerPkgApisCoreV1beta1Quota, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createCoreGardenerCloudV1beta1NamespacedQuota.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1Quota === null || comGithubGardenerGardenerPkgApisCoreV1beta1Quota === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1Quota was null or undefined when calling createCoreGardenerCloudV1beta1NamespacedQuota.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ComGithubGardenerGardenerPkgApisCoreV1beta1Quota>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/quotas`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1Quota,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * create a SecretBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createCoreGardenerCloudV1beta1NamespacedSecretBinding(namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding: ComGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding>>;
    public createCoreGardenerCloudV1beta1NamespacedSecretBinding(namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding: ComGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createCoreGardenerCloudV1beta1NamespacedSecretBinding.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding === null || comGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding was null or undefined when calling createCoreGardenerCloudV1beta1NamespacedSecretBinding.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ComGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/secretbindings`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * create a Shoot
     * @param namespace object name and auth scope, such as for teams and projects
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1Shoot 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createCoreGardenerCloudV1beta1NamespacedShoot(namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1Shoot: ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot>>;
    public createCoreGardenerCloudV1beta1NamespacedShoot(namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1Shoot: ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createCoreGardenerCloudV1beta1NamespacedShoot.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1Shoot === null || comGithubGardenerGardenerPkgApisCoreV1beta1Shoot === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1Shoot was null or undefined when calling createCoreGardenerCloudV1beta1NamespacedShoot.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/shoots`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1Shoot,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * create adminkubeconfig of a Shoot
     * @param name name of the AdminKubeconfigRequest
     * @param namespace object name and auth scope, such as for teams and projects
     * @param comGithubGardenerGardenerPkgApisAuthenticationV1alpha1AdminKubeconfigRequest 
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createCoreGardenerCloudV1beta1NamespacedShootAdminkubeconfig(name: string, namespace: string, comGithubGardenerGardenerPkgApisAuthenticationV1alpha1AdminKubeconfigRequest: ComGithubGardenerGardenerPkgApisAuthenticationV1alpha1AdminKubeconfigRequest, dryRun?: string, fieldManager?: string, fieldValidation?: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisAuthenticationV1alpha1AdminKubeconfigRequest>>;
    public createCoreGardenerCloudV1beta1NamespacedShootAdminkubeconfig(name: string, namespace: string, comGithubGardenerGardenerPkgApisAuthenticationV1alpha1AdminKubeconfigRequest: ComGithubGardenerGardenerPkgApisAuthenticationV1alpha1AdminKubeconfigRequest, dryRun?: string, fieldManager?: string, fieldValidation?: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling createCoreGardenerCloudV1beta1NamespacedShootAdminkubeconfig.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createCoreGardenerCloudV1beta1NamespacedShootAdminkubeconfig.');
        }

        if (comGithubGardenerGardenerPkgApisAuthenticationV1alpha1AdminKubeconfigRequest === null || comGithubGardenerGardenerPkgApisAuthenticationV1alpha1AdminKubeconfigRequest === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisAuthenticationV1alpha1AdminKubeconfigRequest was null or undefined when calling createCoreGardenerCloudV1beta1NamespacedShootAdminkubeconfig.');
        }

        let queryParameters = new URLSearchParams();
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ComGithubGardenerGardenerPkgApisAuthenticationV1alpha1AdminKubeconfigRequest>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/shoots/${encodeURIComponent(String(name))}/adminkubeconfig`,
                    comGithubGardenerGardenerPkgApisAuthenticationV1alpha1AdminKubeconfigRequest,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * create a ShootState
     * @param namespace object name and auth scope, such as for teams and projects
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1ShootState 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createCoreGardenerCloudV1beta1NamespacedShootState(namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1ShootState: ComGithubGardenerGardenerPkgApisCoreV1beta1ShootState, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ShootState>>;
    public createCoreGardenerCloudV1beta1NamespacedShootState(namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1ShootState: ComGithubGardenerGardenerPkgApisCoreV1beta1ShootState, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createCoreGardenerCloudV1beta1NamespacedShootState.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1ShootState === null || comGithubGardenerGardenerPkgApisCoreV1beta1ShootState === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1ShootState was null or undefined when calling createCoreGardenerCloudV1beta1NamespacedShootState.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ComGithubGardenerGardenerPkgApisCoreV1beta1ShootState>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/shootstates`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1ShootState,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * create viewerkubeconfig of a Shoot
     * @param name name of the ViewerKubeconfigRequest
     * @param namespace object name and auth scope, such as for teams and projects
     * @param comGithubGardenerGardenerPkgApisAuthenticationV1alpha1ViewerKubeconfigRequest 
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createCoreGardenerCloudV1beta1NamespacedShootViewerkubeconfig(name: string, namespace: string, comGithubGardenerGardenerPkgApisAuthenticationV1alpha1ViewerKubeconfigRequest: ComGithubGardenerGardenerPkgApisAuthenticationV1alpha1ViewerKubeconfigRequest, dryRun?: string, fieldManager?: string, fieldValidation?: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisAuthenticationV1alpha1ViewerKubeconfigRequest>>;
    public createCoreGardenerCloudV1beta1NamespacedShootViewerkubeconfig(name: string, namespace: string, comGithubGardenerGardenerPkgApisAuthenticationV1alpha1ViewerKubeconfigRequest: ComGithubGardenerGardenerPkgApisAuthenticationV1alpha1ViewerKubeconfigRequest, dryRun?: string, fieldManager?: string, fieldValidation?: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling createCoreGardenerCloudV1beta1NamespacedShootViewerkubeconfig.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createCoreGardenerCloudV1beta1NamespacedShootViewerkubeconfig.');
        }

        if (comGithubGardenerGardenerPkgApisAuthenticationV1alpha1ViewerKubeconfigRequest === null || comGithubGardenerGardenerPkgApisAuthenticationV1alpha1ViewerKubeconfigRequest === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisAuthenticationV1alpha1ViewerKubeconfigRequest was null or undefined when calling createCoreGardenerCloudV1beta1NamespacedShootViewerkubeconfig.');
        }

        let queryParameters = new URLSearchParams();
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ComGithubGardenerGardenerPkgApisAuthenticationV1alpha1ViewerKubeconfigRequest>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/shoots/${encodeURIComponent(String(name))}/viewerkubeconfig`,
                    comGithubGardenerGardenerPkgApisAuthenticationV1alpha1ViewerKubeconfigRequest,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * create a Project
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1Project 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createCoreGardenerCloudV1beta1Project(comGithubGardenerGardenerPkgApisCoreV1beta1Project: ComGithubGardenerGardenerPkgApisCoreV1beta1Project, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Project>>;
    public createCoreGardenerCloudV1beta1Project(comGithubGardenerGardenerPkgApisCoreV1beta1Project: ComGithubGardenerGardenerPkgApisCoreV1beta1Project, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (comGithubGardenerGardenerPkgApisCoreV1beta1Project === null || comGithubGardenerGardenerPkgApisCoreV1beta1Project === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1Project was null or undefined when calling createCoreGardenerCloudV1beta1Project.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ComGithubGardenerGardenerPkgApisCoreV1beta1Project>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/projects`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1Project,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * create a Seed
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1Seed 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createCoreGardenerCloudV1beta1Seed(comGithubGardenerGardenerPkgApisCoreV1beta1Seed: ComGithubGardenerGardenerPkgApisCoreV1beta1Seed, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Seed>>;
    public createCoreGardenerCloudV1beta1Seed(comGithubGardenerGardenerPkgApisCoreV1beta1Seed: ComGithubGardenerGardenerPkgApisCoreV1beta1Seed, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (comGithubGardenerGardenerPkgApisCoreV1beta1Seed === null || comGithubGardenerGardenerPkgApisCoreV1beta1Seed === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1Seed was null or undefined when calling createCoreGardenerCloudV1beta1Seed.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ComGithubGardenerGardenerPkgApisCoreV1beta1Seed>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/seeds`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1Seed,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete a BackupBucket
     * @param name name of the BackupBucket
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1BackupBucket(name: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1BackupBucket(name: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteCoreGardenerCloudV1beta1BackupBucket.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/backupbuckets/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete a CloudProfile
     * @param name name of the CloudProfile
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1CloudProfile(name: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1CloudProfile(name: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteCoreGardenerCloudV1beta1CloudProfile.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/cloudprofiles/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete collection of BackupBucket
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1CollectionBackupBucket(pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1CollectionBackupBucket(pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/backupbuckets`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete collection of CloudProfile
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1CollectionCloudProfile(pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1CollectionCloudProfile(pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/cloudprofiles`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete collection of ControllerDeployment
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1CollectionControllerDeployment(pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1CollectionControllerDeployment(pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/controllerdeployments`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete collection of ControllerInstallation
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1CollectionControllerInstallation(pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1CollectionControllerInstallation(pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/controllerinstallations`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete collection of ControllerRegistration
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1CollectionControllerRegistration(pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1CollectionControllerRegistration(pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/controllerregistrations`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete collection of ExposureClass
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1CollectionExposureClass(pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1CollectionExposureClass(pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/exposureclasses`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete collection of BackupEntry
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1CollectionNamespacedBackupEntry(namespace: string, pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1CollectionNamespacedBackupEntry(namespace: string, pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCoreGardenerCloudV1beta1CollectionNamespacedBackupEntry.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/backupentries`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete collection of InternalSecret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1CollectionNamespacedInternalSecret(namespace: string, pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1CollectionNamespacedInternalSecret(namespace: string, pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCoreGardenerCloudV1beta1CollectionNamespacedInternalSecret.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/internalsecrets`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete collection of NamespacedCloudProfile
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1CollectionNamespacedNamespacedCloudProfile(namespace: string, pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1CollectionNamespacedNamespacedCloudProfile(namespace: string, pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCoreGardenerCloudV1beta1CollectionNamespacedNamespacedCloudProfile.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/namespacedcloudprofiles`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete collection of Quota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1CollectionNamespacedQuota(namespace: string, pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1CollectionNamespacedQuota(namespace: string, pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCoreGardenerCloudV1beta1CollectionNamespacedQuota.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/quotas`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete collection of SecretBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1CollectionNamespacedSecretBinding(namespace: string, pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1CollectionNamespacedSecretBinding(namespace: string, pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCoreGardenerCloudV1beta1CollectionNamespacedSecretBinding.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/secretbindings`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete collection of Shoot
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1CollectionNamespacedShoot(namespace: string, pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1CollectionNamespacedShoot(namespace: string, pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCoreGardenerCloudV1beta1CollectionNamespacedShoot.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/shoots`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete collection of ShootState
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1CollectionNamespacedShootState(namespace: string, pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1CollectionNamespacedShootState(namespace: string, pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCoreGardenerCloudV1beta1CollectionNamespacedShootState.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/shootstates`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete collection of Project
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1CollectionProject(pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1CollectionProject(pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/projects`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete collection of Seed
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1CollectionSeed(pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1CollectionSeed(pretty?: string, _continue?: string, dryRun?: string, fieldSelector?: string, gracePeriodSeconds?: number, labelSelector?: string, limit?: number, orphanDependents?: boolean, propagationPolicy?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/seeds`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete a ControllerDeployment
     * @param name name of the ControllerDeployment
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1ControllerDeployment(name: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1ControllerDeployment(name: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteCoreGardenerCloudV1beta1ControllerDeployment.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/controllerdeployments/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete a ControllerInstallation
     * @param name name of the ControllerInstallation
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1ControllerInstallation(name: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1ControllerInstallation(name: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteCoreGardenerCloudV1beta1ControllerInstallation.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/controllerinstallations/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete a ControllerRegistration
     * @param name name of the ControllerRegistration
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1ControllerRegistration(name: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1ControllerRegistration(name: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteCoreGardenerCloudV1beta1ControllerRegistration.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/controllerregistrations/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete an ExposureClass
     * @param name name of the ExposureClass
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1ExposureClass(name: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1ExposureClass(name: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteCoreGardenerCloudV1beta1ExposureClass.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/exposureclasses/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete a BackupEntry
     * @param name name of the BackupEntry
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1NamespacedBackupEntry(name: string, namespace: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1NamespacedBackupEntry(name: string, namespace: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteCoreGardenerCloudV1beta1NamespacedBackupEntry.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCoreGardenerCloudV1beta1NamespacedBackupEntry.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/backupentries/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete an InternalSecret
     * @param name name of the InternalSecret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1NamespacedInternalSecret(name: string, namespace: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1NamespacedInternalSecret(name: string, namespace: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteCoreGardenerCloudV1beta1NamespacedInternalSecret.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCoreGardenerCloudV1beta1NamespacedInternalSecret.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/internalsecrets/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete a NamespacedCloudProfile
     * @param name name of the NamespacedCloudProfile
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile(name: string, namespace: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile(name: string, namespace: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/namespacedcloudprofiles/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete a Quota
     * @param name name of the Quota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1NamespacedQuota(name: string, namespace: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1NamespacedQuota(name: string, namespace: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteCoreGardenerCloudV1beta1NamespacedQuota.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCoreGardenerCloudV1beta1NamespacedQuota.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/quotas/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete a SecretBinding
     * @param name name of the SecretBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1NamespacedSecretBinding(name: string, namespace: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1NamespacedSecretBinding(name: string, namespace: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteCoreGardenerCloudV1beta1NamespacedSecretBinding.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCoreGardenerCloudV1beta1NamespacedSecretBinding.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/secretbindings/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete a Shoot
     * @param name name of the Shoot
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1NamespacedShoot(name: string, namespace: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1NamespacedShoot(name: string, namespace: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteCoreGardenerCloudV1beta1NamespacedShoot.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCoreGardenerCloudV1beta1NamespacedShoot.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/shoots/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete a ShootState
     * @param name name of the ShootState
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1NamespacedShootState(name: string, namespace: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1NamespacedShootState(name: string, namespace: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteCoreGardenerCloudV1beta1NamespacedShootState.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCoreGardenerCloudV1beta1NamespacedShootState.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/shootstates/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete a Project
     * @param name name of the Project
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1Project(name: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1Project(name: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteCoreGardenerCloudV1beta1Project.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/projects/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * delete a Seed
     * @param name name of the Seed
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param ioK8sApimachineryPkgApisMetaV1DeleteOptions 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCoreGardenerCloudV1beta1Seed(name: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1Status>>;
    public deleteCoreGardenerCloudV1beta1Seed(name: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, ioK8sApimachineryPkgApisMetaV1DeleteOptions?: IoK8sApimachineryPkgApisMetaV1DeleteOptions, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteCoreGardenerCloudV1beta1Seed.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (gracePeriodSeconds !== undefined && gracePeriodSeconds !== null) {
            queryParameters.append('gracePeriodSeconds', <any>gracePeriodSeconds);
        }
        if (orphanDependents !== undefined && orphanDependents !== null) {
            queryParameters.append('orphanDependents', <any>orphanDependents);
        }
        if (propagationPolicy !== undefined && propagationPolicy !== null) {
            queryParameters.append('propagationPolicy', <any>propagationPolicy);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<IoK8sApimachineryPkgApisMetaV1Status>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/seeds/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * get available resources
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCoreGardenerCloudV1beta1APIResources(): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1APIResourceList>>;
    public getCoreGardenerCloudV1beta1APIResources(): Observable<any> {
        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1APIResourceList>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * list or watch objects of kind BackupBucket
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listCoreGardenerCloudV1beta1BackupBucket(pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupBucketList>>;
    public listCoreGardenerCloudV1beta1BackupBucket(pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupBucketList>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/backupbuckets`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * list or watch objects of kind BackupEntry
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listCoreGardenerCloudV1beta1BackupEntryForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntryList>>;
    public listCoreGardenerCloudV1beta1BackupEntryForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntryList>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/backupentries`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * list or watch objects of kind CloudProfile
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listCoreGardenerCloudV1beta1CloudProfile(pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1CloudProfileList>>;
    public listCoreGardenerCloudV1beta1CloudProfile(pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1CloudProfileList>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/cloudprofiles`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * list or watch objects of kind ControllerDeployment
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listCoreGardenerCloudV1beta1ControllerDeployment(pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeploymentList>>;
    public listCoreGardenerCloudV1beta1ControllerDeployment(pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeploymentList>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/controllerdeployments`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * list or watch objects of kind ControllerInstallation
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listCoreGardenerCloudV1beta1ControllerInstallation(pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallationList>>;
    public listCoreGardenerCloudV1beta1ControllerInstallation(pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallationList>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/controllerinstallations`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * list or watch objects of kind ControllerRegistration
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listCoreGardenerCloudV1beta1ControllerRegistration(pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistrationList>>;
    public listCoreGardenerCloudV1beta1ControllerRegistration(pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistrationList>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/controllerregistrations`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * list or watch objects of kind ExposureClass
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listCoreGardenerCloudV1beta1ExposureClass(pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ExposureClassList>>;
    public listCoreGardenerCloudV1beta1ExposureClass(pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1ExposureClassList>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/exposureclasses`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * list or watch objects of kind InternalSecret
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listCoreGardenerCloudV1beta1InternalSecretForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1InternalSecretList>>;
    public listCoreGardenerCloudV1beta1InternalSecretForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1InternalSecretList>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/internalsecrets`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * list or watch objects of kind BackupEntry
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listCoreGardenerCloudV1beta1NamespacedBackupEntry(namespace: string, pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntryList>>;
    public listCoreGardenerCloudV1beta1NamespacedBackupEntry(namespace: string, pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listCoreGardenerCloudV1beta1NamespacedBackupEntry.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntryList>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/backupentries`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * list or watch objects of kind NamespacedCloudProfile
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listCoreGardenerCloudV1beta1NamespacedCloudProfileForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfileList>>;
    public listCoreGardenerCloudV1beta1NamespacedCloudProfileForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfileList>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespacedcloudprofiles`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * list or watch objects of kind InternalSecret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listCoreGardenerCloudV1beta1NamespacedInternalSecret(namespace: string, pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1InternalSecretList>>;
    public listCoreGardenerCloudV1beta1NamespacedInternalSecret(namespace: string, pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listCoreGardenerCloudV1beta1NamespacedInternalSecret.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1InternalSecretList>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/internalsecrets`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * list or watch objects of kind NamespacedCloudProfile
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile(namespace: string, pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfileList>>;
    public listCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile(namespace: string, pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfileList>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/namespacedcloudprofiles`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * list or watch objects of kind Quota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listCoreGardenerCloudV1beta1NamespacedQuota(namespace: string, pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1QuotaList>>;
    public listCoreGardenerCloudV1beta1NamespacedQuota(namespace: string, pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listCoreGardenerCloudV1beta1NamespacedQuota.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1QuotaList>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/quotas`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * list or watch objects of kind SecretBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listCoreGardenerCloudV1beta1NamespacedSecretBinding(namespace: string, pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1SecretBindingList>>;
    public listCoreGardenerCloudV1beta1NamespacedSecretBinding(namespace: string, pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listCoreGardenerCloudV1beta1NamespacedSecretBinding.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1SecretBindingList>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/secretbindings`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * list or watch objects of kind Shoot
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listCoreGardenerCloudV1beta1NamespacedShoot(namespace: string, pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ShootList>>;
    public listCoreGardenerCloudV1beta1NamespacedShoot(namespace: string, pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listCoreGardenerCloudV1beta1NamespacedShoot.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1ShootList>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/shoots`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * list or watch objects of kind ShootState
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listCoreGardenerCloudV1beta1NamespacedShootState(namespace: string, pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ShootStateList>>;
    public listCoreGardenerCloudV1beta1NamespacedShootState(namespace: string, pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listCoreGardenerCloudV1beta1NamespacedShootState.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1ShootStateList>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/shootstates`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * list or watch objects of kind Project
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listCoreGardenerCloudV1beta1Project(pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ProjectList>>;
    public listCoreGardenerCloudV1beta1Project(pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1ProjectList>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/projects`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * list or watch objects of kind Quota
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listCoreGardenerCloudV1beta1QuotaForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1QuotaList>>;
    public listCoreGardenerCloudV1beta1QuotaForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1QuotaList>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/quotas`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * list or watch objects of kind SecretBinding
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listCoreGardenerCloudV1beta1SecretBindingForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1SecretBindingList>>;
    public listCoreGardenerCloudV1beta1SecretBindingForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1SecretBindingList>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/secretbindings`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * list or watch objects of kind Seed
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listCoreGardenerCloudV1beta1Seed(pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1SeedList>>;
    public listCoreGardenerCloudV1beta1Seed(pretty?: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1SeedList>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/seeds`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * list or watch objects of kind Shoot
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listCoreGardenerCloudV1beta1ShootForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ShootList>>;
    public listCoreGardenerCloudV1beta1ShootForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1ShootList>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/shoots`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * list or watch objects of kind ShootState
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listCoreGardenerCloudV1beta1ShootStateForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ShootStateList>>;
    public listCoreGardenerCloudV1beta1ShootStateForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1ShootStateList>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/shootstates`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * partially update the specified BackupBucket
     * @param name name of the BackupBucket
     * @param body 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchCoreGardenerCloudV1beta1BackupBucket(name: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket>>;
    public patchCoreGardenerCloudV1beta1BackupBucket(name: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCoreGardenerCloudV1beta1BackupBucket.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCoreGardenerCloudV1beta1BackupBucket.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (force !== undefined && force !== null) {
            queryParameters.append('force', <any>force);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/apply-patch+yaml',
            'application/json-patch+json',
            'application/merge-patch+json',
            'application/strategic-merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/backupbuckets/${encodeURIComponent(String(name))}`,
                    body,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * partially update status of the specified BackupBucket
     * @param name name of the BackupBucket
     * @param body 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchCoreGardenerCloudV1beta1BackupBucketStatus(name: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket>>;
    public patchCoreGardenerCloudV1beta1BackupBucketStatus(name: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCoreGardenerCloudV1beta1BackupBucketStatus.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCoreGardenerCloudV1beta1BackupBucketStatus.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (force !== undefined && force !== null) {
            queryParameters.append('force', <any>force);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/apply-patch+yaml',
            'application/json-patch+json',
            'application/merge-patch+json',
            'application/strategic-merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/backupbuckets/${encodeURIComponent(String(name))}/status`,
                    body,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * partially update the specified CloudProfile
     * @param name name of the CloudProfile
     * @param body 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchCoreGardenerCloudV1beta1CloudProfile(name: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile>>;
    public patchCoreGardenerCloudV1beta1CloudProfile(name: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCoreGardenerCloudV1beta1CloudProfile.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCoreGardenerCloudV1beta1CloudProfile.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (force !== undefined && force !== null) {
            queryParameters.append('force', <any>force);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/apply-patch+yaml',
            'application/json-patch+json',
            'application/merge-patch+json',
            'application/strategic-merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<ComGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/cloudprofiles/${encodeURIComponent(String(name))}`,
                    body,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * partially update the specified ControllerDeployment
     * @param name name of the ControllerDeployment
     * @param body 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchCoreGardenerCloudV1beta1ControllerDeployment(name: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment>>;
    public patchCoreGardenerCloudV1beta1ControllerDeployment(name: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCoreGardenerCloudV1beta1ControllerDeployment.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCoreGardenerCloudV1beta1ControllerDeployment.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (force !== undefined && force !== null) {
            queryParameters.append('force', <any>force);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/apply-patch+yaml',
            'application/json-patch+json',
            'application/merge-patch+json',
            'application/strategic-merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/controllerdeployments/${encodeURIComponent(String(name))}`,
                    body,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * partially update the specified ControllerInstallation
     * @param name name of the ControllerInstallation
     * @param body 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchCoreGardenerCloudV1beta1ControllerInstallation(name: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation>>;
    public patchCoreGardenerCloudV1beta1ControllerInstallation(name: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCoreGardenerCloudV1beta1ControllerInstallation.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCoreGardenerCloudV1beta1ControllerInstallation.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (force !== undefined && force !== null) {
            queryParameters.append('force', <any>force);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/apply-patch+yaml',
            'application/json-patch+json',
            'application/merge-patch+json',
            'application/strategic-merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/controllerinstallations/${encodeURIComponent(String(name))}`,
                    body,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * partially update status of the specified ControllerInstallation
     * @param name name of the ControllerInstallation
     * @param body 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchCoreGardenerCloudV1beta1ControllerInstallationStatus(name: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation>>;
    public patchCoreGardenerCloudV1beta1ControllerInstallationStatus(name: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCoreGardenerCloudV1beta1ControllerInstallationStatus.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCoreGardenerCloudV1beta1ControllerInstallationStatus.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (force !== undefined && force !== null) {
            queryParameters.append('force', <any>force);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/apply-patch+yaml',
            'application/json-patch+json',
            'application/merge-patch+json',
            'application/strategic-merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/controllerinstallations/${encodeURIComponent(String(name))}/status`,
                    body,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * partially update the specified ControllerRegistration
     * @param name name of the ControllerRegistration
     * @param body 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchCoreGardenerCloudV1beta1ControllerRegistration(name: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration>>;
    public patchCoreGardenerCloudV1beta1ControllerRegistration(name: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCoreGardenerCloudV1beta1ControllerRegistration.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCoreGardenerCloudV1beta1ControllerRegistration.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (force !== undefined && force !== null) {
            queryParameters.append('force', <any>force);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/apply-patch+yaml',
            'application/json-patch+json',
            'application/merge-patch+json',
            'application/strategic-merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/controllerregistrations/${encodeURIComponent(String(name))}`,
                    body,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * partially update the specified ExposureClass
     * @param name name of the ExposureClass
     * @param body 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchCoreGardenerCloudV1beta1ExposureClass(name: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass>>;
    public patchCoreGardenerCloudV1beta1ExposureClass(name: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCoreGardenerCloudV1beta1ExposureClass.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCoreGardenerCloudV1beta1ExposureClass.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (force !== undefined && force !== null) {
            queryParameters.append('force', <any>force);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/apply-patch+yaml',
            'application/json-patch+json',
            'application/merge-patch+json',
            'application/strategic-merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<ComGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/exposureclasses/${encodeURIComponent(String(name))}`,
                    body,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * partially update the specified BackupEntry
     * @param name name of the BackupEntry
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchCoreGardenerCloudV1beta1NamespacedBackupEntry(name: string, namespace: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry>>;
    public patchCoreGardenerCloudV1beta1NamespacedBackupEntry(name: string, namespace: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedBackupEntry.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedBackupEntry.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedBackupEntry.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (force !== undefined && force !== null) {
            queryParameters.append('force', <any>force);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/apply-patch+yaml',
            'application/json-patch+json',
            'application/merge-patch+json',
            'application/strategic-merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/backupentries/${encodeURIComponent(String(name))}`,
                    body,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * partially update status of the specified BackupEntry
     * @param name name of the BackupEntry
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchCoreGardenerCloudV1beta1NamespacedBackupEntryStatus(name: string, namespace: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry>>;
    public patchCoreGardenerCloudV1beta1NamespacedBackupEntryStatus(name: string, namespace: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedBackupEntryStatus.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedBackupEntryStatus.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedBackupEntryStatus.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (force !== undefined && force !== null) {
            queryParameters.append('force', <any>force);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/apply-patch+yaml',
            'application/json-patch+json',
            'application/merge-patch+json',
            'application/strategic-merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/backupentries/${encodeURIComponent(String(name))}/status`,
                    body,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * partially update the specified InternalSecret
     * @param name name of the InternalSecret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchCoreGardenerCloudV1beta1NamespacedInternalSecret(name: string, namespace: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret>>;
    public patchCoreGardenerCloudV1beta1NamespacedInternalSecret(name: string, namespace: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedInternalSecret.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedInternalSecret.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedInternalSecret.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (force !== undefined && force !== null) {
            queryParameters.append('force', <any>force);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/apply-patch+yaml',
            'application/json-patch+json',
            'application/merge-patch+json',
            'application/strategic-merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<ComGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/internalsecrets/${encodeURIComponent(String(name))}`,
                    body,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * partially update the specified NamespacedCloudProfile
     * @param name name of the NamespacedCloudProfile
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile(name: string, namespace: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile>>;
    public patchCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile(name: string, namespace: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (force !== undefined && force !== null) {
            queryParameters.append('force', <any>force);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/apply-patch+yaml',
            'application/json-patch+json',
            'application/merge-patch+json',
            'application/strategic-merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/namespacedcloudprofiles/${encodeURIComponent(String(name))}`,
                    body,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * partially update status of the specified NamespacedCloudProfile
     * @param name name of the NamespacedCloudProfile
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfileStatus(name: string, namespace: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile>>;
    public patchCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfileStatus(name: string, namespace: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfileStatus.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfileStatus.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfileStatus.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (force !== undefined && force !== null) {
            queryParameters.append('force', <any>force);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/apply-patch+yaml',
            'application/json-patch+json',
            'application/merge-patch+json',
            'application/strategic-merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/namespacedcloudprofiles/${encodeURIComponent(String(name))}/status`,
                    body,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * partially update the specified Quota
     * @param name name of the Quota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchCoreGardenerCloudV1beta1NamespacedQuota(name: string, namespace: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Quota>>;
    public patchCoreGardenerCloudV1beta1NamespacedQuota(name: string, namespace: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedQuota.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedQuota.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedQuota.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (force !== undefined && force !== null) {
            queryParameters.append('force', <any>force);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/apply-patch+yaml',
            'application/json-patch+json',
            'application/merge-patch+json',
            'application/strategic-merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<ComGithubGardenerGardenerPkgApisCoreV1beta1Quota>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/quotas/${encodeURIComponent(String(name))}`,
                    body,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * partially update the specified SecretBinding
     * @param name name of the SecretBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchCoreGardenerCloudV1beta1NamespacedSecretBinding(name: string, namespace: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding>>;
    public patchCoreGardenerCloudV1beta1NamespacedSecretBinding(name: string, namespace: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedSecretBinding.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedSecretBinding.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedSecretBinding.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (force !== undefined && force !== null) {
            queryParameters.append('force', <any>force);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/apply-patch+yaml',
            'application/json-patch+json',
            'application/merge-patch+json',
            'application/strategic-merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<ComGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/secretbindings/${encodeURIComponent(String(name))}`,
                    body,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * partially update the specified Shoot
     * @param name name of the Shoot
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchCoreGardenerCloudV1beta1NamespacedShoot(name: string, namespace: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot>>;
    public patchCoreGardenerCloudV1beta1NamespacedShoot(name: string, namespace: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedShoot.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedShoot.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedShoot.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (force !== undefined && force !== null) {
            queryParameters.append('force', <any>force);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/apply-patch+yaml',
            'application/json-patch+json',
            'application/merge-patch+json',
            'application/strategic-merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/shoots/${encodeURIComponent(String(name))}`,
                    body,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * partially update binding of the specified Shoot
     * @param name name of the Shoot
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchCoreGardenerCloudV1beta1NamespacedShootBinding(name: string, namespace: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot>>;
    public patchCoreGardenerCloudV1beta1NamespacedShootBinding(name: string, namespace: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedShootBinding.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedShootBinding.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedShootBinding.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (force !== undefined && force !== null) {
            queryParameters.append('force', <any>force);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/apply-patch+yaml',
            'application/json-patch+json',
            'application/merge-patch+json',
            'application/strategic-merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/shoots/${encodeURIComponent(String(name))}/binding`,
                    body,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * partially update the specified ShootState
     * @param name name of the ShootState
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchCoreGardenerCloudV1beta1NamespacedShootState(name: string, namespace: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ShootState>>;
    public patchCoreGardenerCloudV1beta1NamespacedShootState(name: string, namespace: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedShootState.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedShootState.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedShootState.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (force !== undefined && force !== null) {
            queryParameters.append('force', <any>force);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/apply-patch+yaml',
            'application/json-patch+json',
            'application/merge-patch+json',
            'application/strategic-merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<ComGithubGardenerGardenerPkgApisCoreV1beta1ShootState>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/shootstates/${encodeURIComponent(String(name))}`,
                    body,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * partially update status of the specified Shoot
     * @param name name of the Shoot
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchCoreGardenerCloudV1beta1NamespacedShootStatus(name: string, namespace: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot>>;
    public patchCoreGardenerCloudV1beta1NamespacedShootStatus(name: string, namespace: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedShootStatus.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedShootStatus.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCoreGardenerCloudV1beta1NamespacedShootStatus.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (force !== undefined && force !== null) {
            queryParameters.append('force', <any>force);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/apply-patch+yaml',
            'application/json-patch+json',
            'application/merge-patch+json',
            'application/strategic-merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/shoots/${encodeURIComponent(String(name))}/status`,
                    body,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * partially update the specified Project
     * @param name name of the Project
     * @param body 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchCoreGardenerCloudV1beta1Project(name: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Project>>;
    public patchCoreGardenerCloudV1beta1Project(name: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCoreGardenerCloudV1beta1Project.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCoreGardenerCloudV1beta1Project.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (force !== undefined && force !== null) {
            queryParameters.append('force', <any>force);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/apply-patch+yaml',
            'application/json-patch+json',
            'application/merge-patch+json',
            'application/strategic-merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<ComGithubGardenerGardenerPkgApisCoreV1beta1Project>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/projects/${encodeURIComponent(String(name))}`,
                    body,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * partially update status of the specified Project
     * @param name name of the Project
     * @param body 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchCoreGardenerCloudV1beta1ProjectStatus(name: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Project>>;
    public patchCoreGardenerCloudV1beta1ProjectStatus(name: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCoreGardenerCloudV1beta1ProjectStatus.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCoreGardenerCloudV1beta1ProjectStatus.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (force !== undefined && force !== null) {
            queryParameters.append('force', <any>force);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/apply-patch+yaml',
            'application/json-patch+json',
            'application/merge-patch+json',
            'application/strategic-merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<ComGithubGardenerGardenerPkgApisCoreV1beta1Project>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/projects/${encodeURIComponent(String(name))}/status`,
                    body,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * partially update the specified Seed
     * @param name name of the Seed
     * @param body 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchCoreGardenerCloudV1beta1Seed(name: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Seed>>;
    public patchCoreGardenerCloudV1beta1Seed(name: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCoreGardenerCloudV1beta1Seed.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCoreGardenerCloudV1beta1Seed.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (force !== undefined && force !== null) {
            queryParameters.append('force', <any>force);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/apply-patch+yaml',
            'application/json-patch+json',
            'application/merge-patch+json',
            'application/strategic-merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<ComGithubGardenerGardenerPkgApisCoreV1beta1Seed>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/seeds/${encodeURIComponent(String(name))}`,
                    body,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * partially update status of the specified Seed
     * @param name name of the Seed
     * @param body 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchCoreGardenerCloudV1beta1SeedStatus(name: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Seed>>;
    public patchCoreGardenerCloudV1beta1SeedStatus(name: string, body: object, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, force?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCoreGardenerCloudV1beta1SeedStatus.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCoreGardenerCloudV1beta1SeedStatus.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }
        if (force !== undefined && force !== null) {
            queryParameters.append('force', <any>force);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/apply-patch+yaml',
            'application/json-patch+json',
            'application/merge-patch+json',
            'application/strategic-merge-patch+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<ComGithubGardenerGardenerPkgApisCoreV1beta1Seed>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/seeds/${encodeURIComponent(String(name))}/status`,
                    body,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * read the specified BackupBucket
     * @param name name of the BackupBucket
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public readCoreGardenerCloudV1beta1BackupBucket(name: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket>>;
    public readCoreGardenerCloudV1beta1BackupBucket(name: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCoreGardenerCloudV1beta1BackupBucket.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/backupbuckets/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * read status of the specified BackupBucket
     * @param name name of the BackupBucket
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public readCoreGardenerCloudV1beta1BackupBucketStatus(name: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket>>;
    public readCoreGardenerCloudV1beta1BackupBucketStatus(name: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCoreGardenerCloudV1beta1BackupBucketStatus.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/backupbuckets/${encodeURIComponent(String(name))}/status`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * read the specified CloudProfile
     * @param name name of the CloudProfile
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public readCoreGardenerCloudV1beta1CloudProfile(name: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile>>;
    public readCoreGardenerCloudV1beta1CloudProfile(name: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCoreGardenerCloudV1beta1CloudProfile.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/cloudprofiles/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * read the specified ControllerDeployment
     * @param name name of the ControllerDeployment
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public readCoreGardenerCloudV1beta1ControllerDeployment(name: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment>>;
    public readCoreGardenerCloudV1beta1ControllerDeployment(name: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCoreGardenerCloudV1beta1ControllerDeployment.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/controllerdeployments/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * read the specified ControllerInstallation
     * @param name name of the ControllerInstallation
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public readCoreGardenerCloudV1beta1ControllerInstallation(name: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation>>;
    public readCoreGardenerCloudV1beta1ControllerInstallation(name: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCoreGardenerCloudV1beta1ControllerInstallation.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/controllerinstallations/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * read status of the specified ControllerInstallation
     * @param name name of the ControllerInstallation
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public readCoreGardenerCloudV1beta1ControllerInstallationStatus(name: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation>>;
    public readCoreGardenerCloudV1beta1ControllerInstallationStatus(name: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCoreGardenerCloudV1beta1ControllerInstallationStatus.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/controllerinstallations/${encodeURIComponent(String(name))}/status`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * read the specified ControllerRegistration
     * @param name name of the ControllerRegistration
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public readCoreGardenerCloudV1beta1ControllerRegistration(name: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration>>;
    public readCoreGardenerCloudV1beta1ControllerRegistration(name: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCoreGardenerCloudV1beta1ControllerRegistration.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/controllerregistrations/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * read the specified ExposureClass
     * @param name name of the ExposureClass
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public readCoreGardenerCloudV1beta1ExposureClass(name: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass>>;
    public readCoreGardenerCloudV1beta1ExposureClass(name: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCoreGardenerCloudV1beta1ExposureClass.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/exposureclasses/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * read the specified BackupEntry
     * @param name name of the BackupEntry
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public readCoreGardenerCloudV1beta1NamespacedBackupEntry(name: string, namespace: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry>>;
    public readCoreGardenerCloudV1beta1NamespacedBackupEntry(name: string, namespace: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCoreGardenerCloudV1beta1NamespacedBackupEntry.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readCoreGardenerCloudV1beta1NamespacedBackupEntry.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/backupentries/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * read status of the specified BackupEntry
     * @param name name of the BackupEntry
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public readCoreGardenerCloudV1beta1NamespacedBackupEntryStatus(name: string, namespace: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry>>;
    public readCoreGardenerCloudV1beta1NamespacedBackupEntryStatus(name: string, namespace: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCoreGardenerCloudV1beta1NamespacedBackupEntryStatus.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readCoreGardenerCloudV1beta1NamespacedBackupEntryStatus.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/backupentries/${encodeURIComponent(String(name))}/status`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * read the specified InternalSecret
     * @param name name of the InternalSecret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public readCoreGardenerCloudV1beta1NamespacedInternalSecret(name: string, namespace: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret>>;
    public readCoreGardenerCloudV1beta1NamespacedInternalSecret(name: string, namespace: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCoreGardenerCloudV1beta1NamespacedInternalSecret.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readCoreGardenerCloudV1beta1NamespacedInternalSecret.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/internalsecrets/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * read the specified NamespacedCloudProfile
     * @param name name of the NamespacedCloudProfile
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public readCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile(name: string, namespace: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile>>;
    public readCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile(name: string, namespace: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/namespacedcloudprofiles/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * read status of the specified NamespacedCloudProfile
     * @param name name of the NamespacedCloudProfile
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public readCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfileStatus(name: string, namespace: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile>>;
    public readCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfileStatus(name: string, namespace: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfileStatus.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfileStatus.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/namespacedcloudprofiles/${encodeURIComponent(String(name))}/status`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * read the specified Quota
     * @param name name of the Quota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public readCoreGardenerCloudV1beta1NamespacedQuota(name: string, namespace: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Quota>>;
    public readCoreGardenerCloudV1beta1NamespacedQuota(name: string, namespace: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCoreGardenerCloudV1beta1NamespacedQuota.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readCoreGardenerCloudV1beta1NamespacedQuota.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1Quota>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/quotas/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * read the specified SecretBinding
     * @param name name of the SecretBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public readCoreGardenerCloudV1beta1NamespacedSecretBinding(name: string, namespace: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding>>;
    public readCoreGardenerCloudV1beta1NamespacedSecretBinding(name: string, namespace: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCoreGardenerCloudV1beta1NamespacedSecretBinding.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readCoreGardenerCloudV1beta1NamespacedSecretBinding.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/secretbindings/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * read the specified Shoot
     * @param name name of the Shoot
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public readCoreGardenerCloudV1beta1NamespacedShoot(name: string, namespace: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot>>;
    public readCoreGardenerCloudV1beta1NamespacedShoot(name: string, namespace: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCoreGardenerCloudV1beta1NamespacedShoot.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readCoreGardenerCloudV1beta1NamespacedShoot.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/shoots/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * read binding of the specified Shoot
     * @param name name of the Shoot
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public readCoreGardenerCloudV1beta1NamespacedShootBinding(name: string, namespace: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot>>;
    public readCoreGardenerCloudV1beta1NamespacedShootBinding(name: string, namespace: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCoreGardenerCloudV1beta1NamespacedShootBinding.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readCoreGardenerCloudV1beta1NamespacedShootBinding.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/shoots/${encodeURIComponent(String(name))}/binding`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * read the specified ShootState
     * @param name name of the ShootState
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public readCoreGardenerCloudV1beta1NamespacedShootState(name: string, namespace: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ShootState>>;
    public readCoreGardenerCloudV1beta1NamespacedShootState(name: string, namespace: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCoreGardenerCloudV1beta1NamespacedShootState.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readCoreGardenerCloudV1beta1NamespacedShootState.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1ShootState>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/shootstates/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * read status of the specified Shoot
     * @param name name of the Shoot
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public readCoreGardenerCloudV1beta1NamespacedShootStatus(name: string, namespace: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot>>;
    public readCoreGardenerCloudV1beta1NamespacedShootStatus(name: string, namespace: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCoreGardenerCloudV1beta1NamespacedShootStatus.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readCoreGardenerCloudV1beta1NamespacedShootStatus.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/shoots/${encodeURIComponent(String(name))}/status`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * read the specified Project
     * @param name name of the Project
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public readCoreGardenerCloudV1beta1Project(name: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Project>>;
    public readCoreGardenerCloudV1beta1Project(name: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCoreGardenerCloudV1beta1Project.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1Project>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/projects/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * read status of the specified Project
     * @param name name of the Project
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public readCoreGardenerCloudV1beta1ProjectStatus(name: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Project>>;
    public readCoreGardenerCloudV1beta1ProjectStatus(name: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCoreGardenerCloudV1beta1ProjectStatus.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1Project>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/projects/${encodeURIComponent(String(name))}/status`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * read the specified Seed
     * @param name name of the Seed
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public readCoreGardenerCloudV1beta1Seed(name: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Seed>>;
    public readCoreGardenerCloudV1beta1Seed(name: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCoreGardenerCloudV1beta1Seed.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1Seed>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/seeds/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * read status of the specified Seed
     * @param name name of the Seed
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public readCoreGardenerCloudV1beta1SeedStatus(name: string, pretty?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Seed>>;
    public readCoreGardenerCloudV1beta1SeedStatus(name: string, pretty?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCoreGardenerCloudV1beta1SeedStatus.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ComGithubGardenerGardenerPkgApisCoreV1beta1Seed>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/seeds/${encodeURIComponent(String(name))}/status`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * replace the specified BackupBucket
     * @param name name of the BackupBucket
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceCoreGardenerCloudV1beta1BackupBucket(name: string, comGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket: ComGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket>>;
    public replaceCoreGardenerCloudV1beta1BackupBucket(name: string, comGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket: ComGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCoreGardenerCloudV1beta1BackupBucket.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket === null || comGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket was null or undefined when calling replaceCoreGardenerCloudV1beta1BackupBucket.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/backupbuckets/${encodeURIComponent(String(name))}`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * replace status of the specified BackupBucket
     * @param name name of the BackupBucket
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceCoreGardenerCloudV1beta1BackupBucketStatus(name: string, comGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket: ComGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket>>;
    public replaceCoreGardenerCloudV1beta1BackupBucketStatus(name: string, comGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket: ComGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCoreGardenerCloudV1beta1BackupBucketStatus.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket === null || comGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket was null or undefined when calling replaceCoreGardenerCloudV1beta1BackupBucketStatus.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/backupbuckets/${encodeURIComponent(String(name))}/status`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1BackupBucket,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * replace the specified CloudProfile
     * @param name name of the CloudProfile
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceCoreGardenerCloudV1beta1CloudProfile(name: string, comGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile: ComGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile>>;
    public replaceCoreGardenerCloudV1beta1CloudProfile(name: string, comGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile: ComGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCoreGardenerCloudV1beta1CloudProfile.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile === null || comGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile was null or undefined when calling replaceCoreGardenerCloudV1beta1CloudProfile.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<ComGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/cloudprofiles/${encodeURIComponent(String(name))}`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1CloudProfile,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * replace the specified ControllerDeployment
     * @param name name of the ControllerDeployment
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceCoreGardenerCloudV1beta1ControllerDeployment(name: string, comGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment: ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment>>;
    public replaceCoreGardenerCloudV1beta1ControllerDeployment(name: string, comGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment: ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCoreGardenerCloudV1beta1ControllerDeployment.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment === null || comGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment was null or undefined when calling replaceCoreGardenerCloudV1beta1ControllerDeployment.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/controllerdeployments/${encodeURIComponent(String(name))}`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1ControllerDeployment,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * replace the specified ControllerInstallation
     * @param name name of the ControllerInstallation
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceCoreGardenerCloudV1beta1ControllerInstallation(name: string, comGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation: ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation>>;
    public replaceCoreGardenerCloudV1beta1ControllerInstallation(name: string, comGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation: ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCoreGardenerCloudV1beta1ControllerInstallation.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation === null || comGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation was null or undefined when calling replaceCoreGardenerCloudV1beta1ControllerInstallation.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/controllerinstallations/${encodeURIComponent(String(name))}`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * replace status of the specified ControllerInstallation
     * @param name name of the ControllerInstallation
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceCoreGardenerCloudV1beta1ControllerInstallationStatus(name: string, comGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation: ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation>>;
    public replaceCoreGardenerCloudV1beta1ControllerInstallationStatus(name: string, comGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation: ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCoreGardenerCloudV1beta1ControllerInstallationStatus.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation === null || comGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation was null or undefined when calling replaceCoreGardenerCloudV1beta1ControllerInstallationStatus.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/controllerinstallations/${encodeURIComponent(String(name))}/status`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1ControllerInstallation,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * replace the specified ControllerRegistration
     * @param name name of the ControllerRegistration
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceCoreGardenerCloudV1beta1ControllerRegistration(name: string, comGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration: ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration>>;
    public replaceCoreGardenerCloudV1beta1ControllerRegistration(name: string, comGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration: ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCoreGardenerCloudV1beta1ControllerRegistration.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration === null || comGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration was null or undefined when calling replaceCoreGardenerCloudV1beta1ControllerRegistration.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<ComGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/controllerregistrations/${encodeURIComponent(String(name))}`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1ControllerRegistration,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * replace the specified ExposureClass
     * @param name name of the ExposureClass
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceCoreGardenerCloudV1beta1ExposureClass(name: string, comGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass: ComGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass>>;
    public replaceCoreGardenerCloudV1beta1ExposureClass(name: string, comGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass: ComGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCoreGardenerCloudV1beta1ExposureClass.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass === null || comGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass was null or undefined when calling replaceCoreGardenerCloudV1beta1ExposureClass.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<ComGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/exposureclasses/${encodeURIComponent(String(name))}`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1ExposureClass,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * replace the specified BackupEntry
     * @param name name of the BackupEntry
     * @param namespace object name and auth scope, such as for teams and projects
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceCoreGardenerCloudV1beta1NamespacedBackupEntry(name: string, namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry: ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry>>;
    public replaceCoreGardenerCloudV1beta1NamespacedBackupEntry(name: string, namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry: ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedBackupEntry.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedBackupEntry.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry === null || comGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedBackupEntry.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/backupentries/${encodeURIComponent(String(name))}`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * replace status of the specified BackupEntry
     * @param name name of the BackupEntry
     * @param namespace object name and auth scope, such as for teams and projects
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceCoreGardenerCloudV1beta1NamespacedBackupEntryStatus(name: string, namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry: ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry>>;
    public replaceCoreGardenerCloudV1beta1NamespacedBackupEntryStatus(name: string, namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry: ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedBackupEntryStatus.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedBackupEntryStatus.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry === null || comGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedBackupEntryStatus.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<ComGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/backupentries/${encodeURIComponent(String(name))}/status`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1BackupEntry,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * replace the specified InternalSecret
     * @param name name of the InternalSecret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceCoreGardenerCloudV1beta1NamespacedInternalSecret(name: string, namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret: ComGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret>>;
    public replaceCoreGardenerCloudV1beta1NamespacedInternalSecret(name: string, namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret: ComGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedInternalSecret.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedInternalSecret.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret === null || comGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedInternalSecret.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<ComGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/internalsecrets/${encodeURIComponent(String(name))}`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1InternalSecret,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * replace the specified NamespacedCloudProfile
     * @param name name of the NamespacedCloudProfile
     * @param namespace object name and auth scope, such as for teams and projects
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile(name: string, namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile: ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile>>;
    public replaceCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile(name: string, namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile: ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile === null || comGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/namespacedcloudprofiles/${encodeURIComponent(String(name))}`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * replace status of the specified NamespacedCloudProfile
     * @param name name of the NamespacedCloudProfile
     * @param namespace object name and auth scope, such as for teams and projects
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfileStatus(name: string, namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile: ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile>>;
    public replaceCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfileStatus(name: string, namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile: ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfileStatus.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfileStatus.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile === null || comGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfileStatus.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<ComGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/namespacedcloudprofiles/${encodeURIComponent(String(name))}/status`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1NamespacedCloudProfile,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * replace the specified Quota
     * @param name name of the Quota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1Quota 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceCoreGardenerCloudV1beta1NamespacedQuota(name: string, namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1Quota: ComGithubGardenerGardenerPkgApisCoreV1beta1Quota, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Quota>>;
    public replaceCoreGardenerCloudV1beta1NamespacedQuota(name: string, namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1Quota: ComGithubGardenerGardenerPkgApisCoreV1beta1Quota, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedQuota.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedQuota.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1Quota === null || comGithubGardenerGardenerPkgApisCoreV1beta1Quota === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1Quota was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedQuota.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<ComGithubGardenerGardenerPkgApisCoreV1beta1Quota>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/quotas/${encodeURIComponent(String(name))}`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1Quota,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * replace the specified SecretBinding
     * @param name name of the SecretBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceCoreGardenerCloudV1beta1NamespacedSecretBinding(name: string, namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding: ComGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding>>;
    public replaceCoreGardenerCloudV1beta1NamespacedSecretBinding(name: string, namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding: ComGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedSecretBinding.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedSecretBinding.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding === null || comGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedSecretBinding.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<ComGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/secretbindings/${encodeURIComponent(String(name))}`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1SecretBinding,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * replace the specified Shoot
     * @param name name of the Shoot
     * @param namespace object name and auth scope, such as for teams and projects
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1Shoot 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceCoreGardenerCloudV1beta1NamespacedShoot(name: string, namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1Shoot: ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot>>;
    public replaceCoreGardenerCloudV1beta1NamespacedShoot(name: string, namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1Shoot: ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedShoot.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedShoot.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1Shoot === null || comGithubGardenerGardenerPkgApisCoreV1beta1Shoot === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1Shoot was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedShoot.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/shoots/${encodeURIComponent(String(name))}`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1Shoot,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * replace binding of the specified Shoot
     * @param name name of the Shoot
     * @param namespace object name and auth scope, such as for teams and projects
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1Shoot 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceCoreGardenerCloudV1beta1NamespacedShootBinding(name: string, namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1Shoot: ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot>>;
    public replaceCoreGardenerCloudV1beta1NamespacedShootBinding(name: string, namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1Shoot: ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedShootBinding.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedShootBinding.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1Shoot === null || comGithubGardenerGardenerPkgApisCoreV1beta1Shoot === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1Shoot was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedShootBinding.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/shoots/${encodeURIComponent(String(name))}/binding`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1Shoot,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * replace the specified ShootState
     * @param name name of the ShootState
     * @param namespace object name and auth scope, such as for teams and projects
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1ShootState 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceCoreGardenerCloudV1beta1NamespacedShootState(name: string, namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1ShootState: ComGithubGardenerGardenerPkgApisCoreV1beta1ShootState, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1ShootState>>;
    public replaceCoreGardenerCloudV1beta1NamespacedShootState(name: string, namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1ShootState: ComGithubGardenerGardenerPkgApisCoreV1beta1ShootState, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedShootState.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedShootState.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1ShootState === null || comGithubGardenerGardenerPkgApisCoreV1beta1ShootState === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1ShootState was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedShootState.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<ComGithubGardenerGardenerPkgApisCoreV1beta1ShootState>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/shootstates/${encodeURIComponent(String(name))}`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1ShootState,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * replace status of the specified Shoot
     * @param name name of the Shoot
     * @param namespace object name and auth scope, such as for teams and projects
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1Shoot 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceCoreGardenerCloudV1beta1NamespacedShootStatus(name: string, namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1Shoot: ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot>>;
    public replaceCoreGardenerCloudV1beta1NamespacedShootStatus(name: string, namespace: string, comGithubGardenerGardenerPkgApisCoreV1beta1Shoot: ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedShootStatus.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedShootStatus.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1Shoot === null || comGithubGardenerGardenerPkgApisCoreV1beta1Shoot === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1Shoot was null or undefined when calling replaceCoreGardenerCloudV1beta1NamespacedShootStatus.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<ComGithubGardenerGardenerPkgApisCoreV1beta1Shoot>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/namespaces/${encodeURIComponent(String(namespace))}/shoots/${encodeURIComponent(String(name))}/status`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1Shoot,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * replace the specified Project
     * @param name name of the Project
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1Project 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceCoreGardenerCloudV1beta1Project(name: string, comGithubGardenerGardenerPkgApisCoreV1beta1Project: ComGithubGardenerGardenerPkgApisCoreV1beta1Project, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Project>>;
    public replaceCoreGardenerCloudV1beta1Project(name: string, comGithubGardenerGardenerPkgApisCoreV1beta1Project: ComGithubGardenerGardenerPkgApisCoreV1beta1Project, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCoreGardenerCloudV1beta1Project.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1Project === null || comGithubGardenerGardenerPkgApisCoreV1beta1Project === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1Project was null or undefined when calling replaceCoreGardenerCloudV1beta1Project.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<ComGithubGardenerGardenerPkgApisCoreV1beta1Project>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/projects/${encodeURIComponent(String(name))}`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1Project,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * replace status of the specified Project
     * @param name name of the Project
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1Project 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceCoreGardenerCloudV1beta1ProjectStatus(name: string, comGithubGardenerGardenerPkgApisCoreV1beta1Project: ComGithubGardenerGardenerPkgApisCoreV1beta1Project, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Project>>;
    public replaceCoreGardenerCloudV1beta1ProjectStatus(name: string, comGithubGardenerGardenerPkgApisCoreV1beta1Project: ComGithubGardenerGardenerPkgApisCoreV1beta1Project, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCoreGardenerCloudV1beta1ProjectStatus.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1Project === null || comGithubGardenerGardenerPkgApisCoreV1beta1Project === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1Project was null or undefined when calling replaceCoreGardenerCloudV1beta1ProjectStatus.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<ComGithubGardenerGardenerPkgApisCoreV1beta1Project>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/projects/${encodeURIComponent(String(name))}/status`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1Project,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * replace the specified Seed
     * @param name name of the Seed
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1Seed 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceCoreGardenerCloudV1beta1Seed(name: string, comGithubGardenerGardenerPkgApisCoreV1beta1Seed: ComGithubGardenerGardenerPkgApisCoreV1beta1Seed, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Seed>>;
    public replaceCoreGardenerCloudV1beta1Seed(name: string, comGithubGardenerGardenerPkgApisCoreV1beta1Seed: ComGithubGardenerGardenerPkgApisCoreV1beta1Seed, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCoreGardenerCloudV1beta1Seed.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1Seed === null || comGithubGardenerGardenerPkgApisCoreV1beta1Seed === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1Seed was null or undefined when calling replaceCoreGardenerCloudV1beta1Seed.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<ComGithubGardenerGardenerPkgApisCoreV1beta1Seed>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/seeds/${encodeURIComponent(String(name))}`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1Seed,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * replace status of the specified Seed
     * @param name name of the Seed
     * @param comGithubGardenerGardenerPkgApisCoreV1beta1Seed 
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @param fieldValidation fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public replaceCoreGardenerCloudV1beta1SeedStatus(name: string, comGithubGardenerGardenerPkgApisCoreV1beta1Seed: ComGithubGardenerGardenerPkgApisCoreV1beta1Seed, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<AxiosResponse<ComGithubGardenerGardenerPkgApisCoreV1beta1Seed>>;
    public replaceCoreGardenerCloudV1beta1SeedStatus(name: string, comGithubGardenerGardenerPkgApisCoreV1beta1Seed: ComGithubGardenerGardenerPkgApisCoreV1beta1Seed, pretty?: string, dryRun?: string, fieldManager?: string, fieldValidation?: string, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCoreGardenerCloudV1beta1SeedStatus.');
        }

        if (comGithubGardenerGardenerPkgApisCoreV1beta1Seed === null || comGithubGardenerGardenerPkgApisCoreV1beta1Seed === undefined) {
            throw new Error('Required parameter comGithubGardenerGardenerPkgApisCoreV1beta1Seed was null or undefined when calling replaceCoreGardenerCloudV1beta1SeedStatus.');
        }

        let queryParameters = new URLSearchParams();
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (dryRun !== undefined && dryRun !== null) {
            queryParameters.append('dryRun', <any>dryRun);
        }
        if (fieldManager !== undefined && fieldManager !== null) {
            queryParameters.append('fieldManager', <any>fieldManager);
        }
        if (fieldValidation !== undefined && fieldValidation !== null) {
            queryParameters.append('fieldValidation', <any>fieldValidation);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/vnd.kubernetes.protobuf',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<ComGithubGardenerGardenerPkgApisCoreV1beta1Seed>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/seeds/${encodeURIComponent(String(name))}/status`,
                    comGithubGardenerGardenerPkgApisCoreV1beta1Seed,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch changes to an object of kind BackupBucket. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead, filtered to a single item with the \&#39;fieldSelector\&#39; parameter.
     * @param name name of the BackupBucket
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1BackupBucket(name: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1BackupBucket(name: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling watchCoreGardenerCloudV1beta1BackupBucket.');
        }

        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/backupbuckets/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch individual changes to a list of BackupBucket. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1BackupBucketList(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1BackupBucketList(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/backupbuckets`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch individual changes to a list of BackupEntry. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1BackupEntryListForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1BackupEntryListForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/backupentries`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch changes to an object of kind CloudProfile. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead, filtered to a single item with the \&#39;fieldSelector\&#39; parameter.
     * @param name name of the CloudProfile
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1CloudProfile(name: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1CloudProfile(name: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling watchCoreGardenerCloudV1beta1CloudProfile.');
        }

        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/cloudprofiles/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch individual changes to a list of CloudProfile. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1CloudProfileList(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1CloudProfileList(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/cloudprofiles`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch changes to an object of kind ControllerDeployment. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead, filtered to a single item with the \&#39;fieldSelector\&#39; parameter.
     * @param name name of the ControllerDeployment
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1ControllerDeployment(name: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1ControllerDeployment(name: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling watchCoreGardenerCloudV1beta1ControllerDeployment.');
        }

        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/controllerdeployments/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch individual changes to a list of ControllerDeployment. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1ControllerDeploymentList(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1ControllerDeploymentList(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/controllerdeployments`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch changes to an object of kind ControllerInstallation. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead, filtered to a single item with the \&#39;fieldSelector\&#39; parameter.
     * @param name name of the ControllerInstallation
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1ControllerInstallation(name: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1ControllerInstallation(name: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling watchCoreGardenerCloudV1beta1ControllerInstallation.');
        }

        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/controllerinstallations/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch individual changes to a list of ControllerInstallation. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1ControllerInstallationList(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1ControllerInstallationList(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/controllerinstallations`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch changes to an object of kind ControllerRegistration. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead, filtered to a single item with the \&#39;fieldSelector\&#39; parameter.
     * @param name name of the ControllerRegistration
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1ControllerRegistration(name: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1ControllerRegistration(name: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling watchCoreGardenerCloudV1beta1ControllerRegistration.');
        }

        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/controllerregistrations/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch individual changes to a list of ControllerRegistration. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1ControllerRegistrationList(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1ControllerRegistrationList(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/controllerregistrations`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch changes to an object of kind ExposureClass. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead, filtered to a single item with the \&#39;fieldSelector\&#39; parameter.
     * @param name name of the ExposureClass
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1ExposureClass(name: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1ExposureClass(name: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling watchCoreGardenerCloudV1beta1ExposureClass.');
        }

        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/exposureclasses/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch individual changes to a list of ExposureClass. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1ExposureClassList(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1ExposureClassList(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/exposureclasses`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch individual changes to a list of InternalSecret. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1InternalSecretListForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1InternalSecretListForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/internalsecrets`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch changes to an object of kind BackupEntry. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead, filtered to a single item with the \&#39;fieldSelector\&#39; parameter.
     * @param name name of the BackupEntry
     * @param namespace object name and auth scope, such as for teams and projects
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1NamespacedBackupEntry(name: string, namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1NamespacedBackupEntry(name: string, namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling watchCoreGardenerCloudV1beta1NamespacedBackupEntry.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling watchCoreGardenerCloudV1beta1NamespacedBackupEntry.');
        }

        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/namespaces/${encodeURIComponent(String(namespace))}/backupentries/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch individual changes to a list of BackupEntry. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead.
     * @param namespace object name and auth scope, such as for teams and projects
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1NamespacedBackupEntryList(namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1NamespacedBackupEntryList(namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling watchCoreGardenerCloudV1beta1NamespacedBackupEntryList.');
        }

        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/namespaces/${encodeURIComponent(String(namespace))}/backupentries`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch individual changes to a list of NamespacedCloudProfile. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1NamespacedCloudProfileListForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1NamespacedCloudProfileListForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/namespacedcloudprofiles`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch changes to an object of kind InternalSecret. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead, filtered to a single item with the \&#39;fieldSelector\&#39; parameter.
     * @param name name of the InternalSecret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1NamespacedInternalSecret(name: string, namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1NamespacedInternalSecret(name: string, namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling watchCoreGardenerCloudV1beta1NamespacedInternalSecret.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling watchCoreGardenerCloudV1beta1NamespacedInternalSecret.');
        }

        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/namespaces/${encodeURIComponent(String(namespace))}/internalsecrets/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch individual changes to a list of InternalSecret. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead.
     * @param namespace object name and auth scope, such as for teams and projects
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1NamespacedInternalSecretList(namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1NamespacedInternalSecretList(namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling watchCoreGardenerCloudV1beta1NamespacedInternalSecretList.');
        }

        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/namespaces/${encodeURIComponent(String(namespace))}/internalsecrets`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch changes to an object of kind NamespacedCloudProfile. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead, filtered to a single item with the \&#39;fieldSelector\&#39; parameter.
     * @param name name of the NamespacedCloudProfile
     * @param namespace object name and auth scope, such as for teams and projects
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile(name: string, namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile(name: string, namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling watchCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling watchCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfile.');
        }

        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/namespaces/${encodeURIComponent(String(namespace))}/namespacedcloudprofiles/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch individual changes to a list of NamespacedCloudProfile. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead.
     * @param namespace object name and auth scope, such as for teams and projects
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfileList(namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfileList(namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling watchCoreGardenerCloudV1beta1NamespacedNamespacedCloudProfileList.');
        }

        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/namespaces/${encodeURIComponent(String(namespace))}/namespacedcloudprofiles`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch changes to an object of kind Quota. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead, filtered to a single item with the \&#39;fieldSelector\&#39; parameter.
     * @param name name of the Quota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1NamespacedQuota(name: string, namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1NamespacedQuota(name: string, namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling watchCoreGardenerCloudV1beta1NamespacedQuota.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling watchCoreGardenerCloudV1beta1NamespacedQuota.');
        }

        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/namespaces/${encodeURIComponent(String(namespace))}/quotas/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch individual changes to a list of Quota. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead.
     * @param namespace object name and auth scope, such as for teams and projects
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1NamespacedQuotaList(namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1NamespacedQuotaList(namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling watchCoreGardenerCloudV1beta1NamespacedQuotaList.');
        }

        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/namespaces/${encodeURIComponent(String(namespace))}/quotas`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch changes to an object of kind SecretBinding. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead, filtered to a single item with the \&#39;fieldSelector\&#39; parameter.
     * @param name name of the SecretBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1NamespacedSecretBinding(name: string, namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1NamespacedSecretBinding(name: string, namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling watchCoreGardenerCloudV1beta1NamespacedSecretBinding.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling watchCoreGardenerCloudV1beta1NamespacedSecretBinding.');
        }

        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/namespaces/${encodeURIComponent(String(namespace))}/secretbindings/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch individual changes to a list of SecretBinding. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead.
     * @param namespace object name and auth scope, such as for teams and projects
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1NamespacedSecretBindingList(namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1NamespacedSecretBindingList(namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling watchCoreGardenerCloudV1beta1NamespacedSecretBindingList.');
        }

        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/namespaces/${encodeURIComponent(String(namespace))}/secretbindings`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch changes to an object of kind Shoot. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead, filtered to a single item with the \&#39;fieldSelector\&#39; parameter.
     * @param name name of the Shoot
     * @param namespace object name and auth scope, such as for teams and projects
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1NamespacedShoot(name: string, namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1NamespacedShoot(name: string, namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling watchCoreGardenerCloudV1beta1NamespacedShoot.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling watchCoreGardenerCloudV1beta1NamespacedShoot.');
        }

        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/namespaces/${encodeURIComponent(String(namespace))}/shoots/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch individual changes to a list of Shoot. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead.
     * @param namespace object name and auth scope, such as for teams and projects
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1NamespacedShootList(namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1NamespacedShootList(namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling watchCoreGardenerCloudV1beta1NamespacedShootList.');
        }

        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/namespaces/${encodeURIComponent(String(namespace))}/shoots`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch changes to an object of kind ShootState. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead, filtered to a single item with the \&#39;fieldSelector\&#39; parameter.
     * @param name name of the ShootState
     * @param namespace object name and auth scope, such as for teams and projects
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1NamespacedShootState(name: string, namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1NamespacedShootState(name: string, namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling watchCoreGardenerCloudV1beta1NamespacedShootState.');
        }

        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling watchCoreGardenerCloudV1beta1NamespacedShootState.');
        }

        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/namespaces/${encodeURIComponent(String(namespace))}/shootstates/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch individual changes to a list of ShootState. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead.
     * @param namespace object name and auth scope, such as for teams and projects
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1NamespacedShootStateList(namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1NamespacedShootStateList(namespace: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling watchCoreGardenerCloudV1beta1NamespacedShootStateList.');
        }

        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/namespaces/${encodeURIComponent(String(namespace))}/shootstates`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch changes to an object of kind Project. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead, filtered to a single item with the \&#39;fieldSelector\&#39; parameter.
     * @param name name of the Project
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1Project(name: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1Project(name: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling watchCoreGardenerCloudV1beta1Project.');
        }

        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/projects/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch individual changes to a list of Project. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1ProjectList(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1ProjectList(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/projects`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch individual changes to a list of Quota. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1QuotaListForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1QuotaListForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/quotas`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch individual changes to a list of SecretBinding. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1SecretBindingListForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1SecretBindingListForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/secretbindings`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch changes to an object of kind Seed. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead, filtered to a single item with the \&#39;fieldSelector\&#39; parameter.
     * @param name name of the Seed
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1Seed(name: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1Seed(name: string, allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling watchCoreGardenerCloudV1beta1Seed.');
        }

        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/seeds/${encodeURIComponent(String(name))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch individual changes to a list of Seed. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1SeedList(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1SeedList(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/seeds`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch individual changes to a list of Shoot. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1ShootListForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1ShootListForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/shoots`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * 
     * watch individual changes to a list of ShootState. deprecated: use the \&#39;watch\&#39; parameter with a list operation instead.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * @param resourceVersion resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param resourceVersionMatch resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @param sendInitialEvents &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public watchCoreGardenerCloudV1beta1ShootStateListForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<AxiosResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>>;
    public watchCoreGardenerCloudV1beta1ShootStateListForAllNamespaces(allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, resourceVersionMatch?: string, sendInitialEvents?: boolean, timeoutSeconds?: number, watch?: boolean, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (allowWatchBookmarks !== undefined && allowWatchBookmarks !== null) {
            queryParameters.append('allowWatchBookmarks', <any>allowWatchBookmarks);
        }
        if (_continue !== undefined && _continue !== null) {
            queryParameters.append('continue', <any>_continue);
        }
        if (fieldSelector !== undefined && fieldSelector !== null) {
            queryParameters.append('fieldSelector', <any>fieldSelector);
        }
        if (labelSelector !== undefined && labelSelector !== null) {
            queryParameters.append('labelSelector', <any>labelSelector);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters.append('pretty', <any>pretty);
        }
        if (resourceVersion !== undefined && resourceVersion !== null) {
            queryParameters.append('resourceVersion', <any>resourceVersion);
        }
        if (resourceVersionMatch !== undefined && resourceVersionMatch !== null) {
            queryParameters.append('resourceVersionMatch', <any>resourceVersionMatch);
        }
        if (sendInitialEvents !== undefined && sendInitialEvents !== null) {
            queryParameters.append('sendInitialEvents', <any>sendInitialEvents);
        }
        if (timeoutSeconds !== undefined && timeoutSeconds !== null) {
            queryParameters.append('timeoutSeconds', <any>timeoutSeconds);
        }
        if (watch !== undefined && watch !== null) {
            queryParameters.append('watch', <any>watch);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/json;stream=watch',
            'application/vnd.kubernetes.protobuf',
            'application/vnd.kubernetes.protobuf;stream=watch',
            'application/yaml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<IoK8sApimachineryPkgApisMetaV1WatchEvent>(`${this.basePath}/apis/core.gardener.cloud/v1beta1/watch/shootstates`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
}
